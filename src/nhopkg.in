#!/bin/bash
###############################################################################
#	nhopkg v. @PACKAGE_VERSION@ @RELEASEDATE@  <http://nhopkg.sourceforge.net>
#
#	Nhopkg is an universal package manager.
#	It can be used in any GNU/linux distribution and uses .nho  packages
#	(binary) and  .srcnho  packages (source).
#
#	Copyright (C) 2008-2009  Jaime Gil de Sagredo Luna <jaimegildesagredo@gmail.com>
#	Copyright (C) 2009-2025  Carlos Sánchez <cargabsj175@gmail.com>
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################
#
#==============================================================================
# Section: Basic configurations.
#==============================================================================
## Nhopkg basic variables and configurations. Please don't edit these.
# Get the config file.
prefix="@prefix@"
NHOPKG_CONF="@sysconfdir@/nhopkg/nhopkg.conf"
NHOPKG_CONF_DEFAULT="@pkgdatadir@/nhopkg.conf"
if [[ -e "${NHOPKG_CONF}" ]]; then
	source "${NHOPKG_CONF}" 2> /dev/null
elif [[ -e "${NHOPKG_CONF_DEFAULT}" ]]; then
	echog " * Unable to locate Nhopkg configuration file!"
	echog " - Loading default Nhopkg configuration file..."
	source "${NHOPKG_CONF_DEFAULT}" 2> /dev/null
else
	echog " * Unable to locate Nhopkg configuration file!"
	exit 1
fi
# Nhopkg version.
NHOPKG_VERSION="@PACKAGE_VERSION@"
# Edit this variable could cause problems.
NHOID_VERSION="0.5"
# Get default IFS variable.
OLDIFS="${IFS}"
# Configuration of the "locate" binary, preferably "mlocate" if available.
if command -v mlocate &>/dev/null; then
    export BINLOCATE=$(command -v mlocate | grep -o '[^/]*$')
elif command -v locate &>/dev/null; then
    export BINLOCATE=$(command -v locate | grep -o '[^/]*$' )
fi
#==============================================================================
# Section: Nhopkg colorized script.
#==============================================================================
NORMAL="\\033[0;39m"
BOLD="\\033[1;39m"
#==============================================================================
# Section: Nhopkg progress bar variables.
#==============================================================================
PROGRESS_BAR_BEGIN='='
PROGRESS_BAR_END='>'
PROGRESS_BAR_EMPTY=' '
#==============================================================================
# Section: Nhopkg multilanguage (gettext).
#==============================================================================
# Is needed export TEXTDOMAIN and TEXTDOMAINDIR variables to work correctly with gettext.
export TEXTDOMAIN TEXTDOMAINDIR
# ---------------------------------------------------------
# echog()
# Description: Print messages in system languaje with new line.
# Parameters: "Message to user."
# Returns: 0 in success.
# ---------------------------------------------------------
echog()
{
	if [[ "${NHOPKG_GETTEXT}" = "yes" ]]; then
		gettext -es "${*}"
	else
		printf "%b\n" "${*}"
	fi
	# Success.
	return 0
}
# ---------------------------------------------------------
# echogn()
# Description: Print messages in system languaje without new line.
# Parameters: "Message to user."
# Returns: 0 in success.
# ---------------------------------------------------------
echogn()
{
	if [[ "${NHOPKG_GETTEXT}" = "yes" ]]; then
		gettext -ens "${*}"
	else
		printf "%b" "${*}"
	fi
	# Success.
	return 0
}

#==============================================================================
# Section: Nhopkg functions.
#==============================================================================
#======================================0
# Basic nhopkg functions
#======================================0
# ---------------------------------------------------------
# get_good_file_name()
# Description: This is used to get the good file name to search dependencies.
# Parameters: file_name
# Returns: 0 in success and GOOD_FILE_NAME variable.
# ---------------------------------------------------------
get_good_file_name()
{
	REAL_FILE_NAME="${1}"
	REAL_FILE_NAME_WITH_SPACES=$(echo "${REAL_FILE_NAME}" | sed -e 's@/@ @g')
	REAL_FILE_NAME_BAR_NUMS=$(echo "${REAL_FILE_NAME_WITH_SPACES}" | wc -w)
	if (( ${REAL_FILE_NAME_BAR_NUMS} <= 2 )) && \
	(( ${REAL_FILE_NAME_BAR_NUMS} > 0 )); then
		GOOD_FILE_NAME="${REAL_FILE_NAME}"
	elif [[ "${REAL_FILE_NAME_BAR_NUMS}" = "3" ]]; then
		GOOD_FILE_NAME="${REAL_FILE_NAME#/*/}"
	elif [[ "${REAL_FILE_NAME_BAR_NUMS}" = "4" ]]; then
		GOOD_FILE_NAME="${REAL_FILE_NAME#/*/*/}"
	elif [[ "${REAL_FILE_NAME_BAR_NUMS}" = "5" ]]; then
		GOOD_FILE_NAME="${REAL_FILE_NAME#/*/*/*/}"
	elif [[ "${REAL_FILE_NAME_BAR_NUMS}" = "6" ]]; then
		GOOD_FILE_NAME="${REAL_FILE_NAME#/*/*/*/*/}"
	elif (( "${REAL_FILE_NAME_BAR_NUMS}" > "6" )); then
		GOOD_FILE_NAME="${REAL_FILE_NAME#/*/*/*/*/*/}"
	fi
	# Success.
	return 0
}
# ---------------------------------------------------------
# noemptyfuncs()
# Description: This is used if you don't want a bash error if any is empty.
# Parameters: none
# Returns: 0 in any way.
# ---------------------------------------------------------
noemptyfuncs()
{
	# Do you prefer other?
	#echo -n
	#:
	return 0 # Best than others.
}
# ---------------------------------------------------------
# append_npostinstall()
# Description: Extracts and accumulates the commands defined in the
#              npostinstall() section of a package nhoid into a deferred
#              postinstall script when --root is used.
#
#              This prevents execution of post-install actions on the host
#              system and allows them to be executed later inside a chroot.
#
#              Empty or placeholder postinstall definitions
#              (noemptyfuncs or :) are ignored.
#
# Parameters: none
# Returns: 0 if no valid npostinstall section exists,
#          if it is empty, or after successfully appending
#          its commands to the postinstall script.
# ---------------------------------------------------------
append_npostinstall() {
    [ -z "$NHOPKG_ROOT" ] && return 0

    POSTROOT="$NHOPKG_ROOT/usr/local/bin"
    POSTSCRIPT="$POSTROOT/postinstall.sh"
    mkdir -p "$POSTROOT"

    # Crear script si no existe
    if [ ! -f "$POSTSCRIPT" ]; then
        cat > "$POSTSCRIPT" <<'EOF'
#!/bin/sh
set -e

# NeonatoX accumulated postinstall
# Ejecutar SOLO dentro del chroot

# Defensive placeholder (should never be used)
noemptyfuncs() { :; }
EOF
        chmod +x "$POSTSCRIPT"
    fi

    # Extraer cuerpo real de npostinstall desde el nhoid
    body="$(
        sed -n '/^npostinstall() {/,/^}/p' "${NHOPKG_TMPDIR}/nhoid" \
        | sed '1d;$d' \
        | sed '/^[[:space:]]*$/d'
    )"

    # Ignorar placeholders
    echo "$body" | grep -Eq '^(noemptyfuncs|:)[[:space:]]*$' && return 0

    # Si quedó vacío, no hacer nada
    [ -z "$body" ] && return 0

    {
        echo ""
        echo "# --- ${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision} ---"
        echo "$body"
    } >> "$POSTSCRIPT"
}
# ---------------------------------------------------------
# get_packages_by_group()
# Description:
#   Lists all package filenames that belong to a given group
#   across all active repositories.
#
#   It scans the local repository metadata and matches the
#   "# Group:" field inside each package description file.
#
# Parameters:
#   $1  Group name to search (e.g. "base", "core", "libs")
#
# Behavior:
#   - Uses NHOPKG_ACTIVE_REPOS (defaults to "extra" if unset)
#   - Skips symlinks
#   - Prints only package file names (basename)
#
# Returns:
#   0 always. Output is written to stdout.
# ---------------------------------------------------------
get_packages_by_group() {
    group="$1"
    repo_dir="$NHOPKG_LOCALSTATEDIR/repo"

    [ -z "$NHOPKG_ACTIVE_REPOS" ] && NHOPKG_ACTIVE_REPOS="extra"

    for repo in $NHOPKG_ACTIVE_REPOS; do
        pkgdir="$repo_dir/$repo/packages"
        [ -d "$pkgdir" ] || continue

        find "$pkgdir" -maxdepth 1 -type f -print | while IFS= read -r pkg_file; do
            [ -L "$pkg_file" ] && continue
            pkg_group=$(sed -n 's/^# Group:[[:space:]]*//p' "$pkg_file")
            if [ "$pkg_group" = "$group" ]; then
                basename "$pkg_file"
            fi
        done
    done
}
# ---------------------------------------------------------
# install_init_unit()
# Description: Install or remove init service units using
#              external providers (BLFS).
#              Automatically selects the backend according
#              to INITSYSTEM (systemd or sysvinit).
#              Action "remove" is normalized to "uninstall".
# Parameters:
#   $1 - Action: install | remove
#   $2 - Service name (must match Makefile target name)
# Returns:
#   0 on success or if init system is unsupported.
#   1 on error (missing parameters, download/extract failure).
# ---------------------------------------------------------
install_init_unit()
{
    action="$1"    # install | remove
    service="$2"   # ej: slapd

    [ -n "$action" ] && [ -n "$service" ] || return 1

    # Normalizar acción
    [ "$action" = "remove" ] && action="uninstall"

    case "$INITSYSTEM" in
        systemd)
            dir="$SYSTEMD_BLFS_DIR"
            url="$SYSTEMD_BLFS_URL"
            ;;
        sysvinit)
            dir="$SYSV_BLFS_DIR"
            url="$SYSV_BLFS_URL"
            ;;
        *)
            return 0
            ;;
    esac

    if [ ! -d "$dir" ]; then
        wget -qO- "$url" | tar -xJ -C /usr/src || return 1
    fi

    cd "$dir" || return 1
    echogn " --- Installing service: "
    echo "${service}"
    make "${action}-${service}"
}
# ---------------------------------------------------------
# nhouser()
# Description: Creates or verifies system users and groups.
#              Supports idempotent operation for package scripts,
#              allowing safe execution during build, install, or
#              post-install phases.
#              User and group creation is performed only when needed,
#              following BLFS/LFS conventions.
# Parameters: Command-line options (--check, --create, --user, --group,
#             --uid, --gid, --shell, --groups, etc.)
# Returns: 0 on success, non-zero on error
# ---------------------------------------------------------
nhouser() {
    MODE=""
    VERBOSE=0

    USER= U_ID= COMMENT= HOME= SHELL=
    GNAME= G_ID= GROUPS=
    GROUP_DONE=0

    log() { [ "$VERBOSE" = 1 ] && echog "$*"; }

    user_exists() { id "$1" >/dev/null 2>&1; }
    group_exists() { grep -q "^$1:" /etc/group; }

    usage() {
        echo "nhouser --check|--create --user NAME [options]"
        echo "nhouser --check|--create --group NAME [--gid GID]"
    }

    while [ $# -gt 0 ]; do
        case "$1" in
            --check|--create) MODE="$1" ;;
            --verbose) VERBOSE=1 ;;
            --user) USER="$2"; shift ;;
            --uid) U_ID="$2"; shift ;;
            --uname) COMMENT="$2"; shift ;;
            --udir) HOME="$2"; shift ;;
            --shell) SHELL="$2"; shift ;;
            --group) GNAME="$2"; shift ;;
            --gid) G_ID="$2"; shift ;;
            --groups) GROUPS="$2"; shift ;;
            --help) usage; return 0 ;;
            *) echo "Opción inválida: $1" >&2; return 1 ;;
        esac
        shift
    done

    [ -z "$MODE" ] && { echo "Missing --check or --create" >&2; return 1; }
    [ -z "$USER$GNAME" ] && { echo "Missing --user or --group" >&2; return 1; }

    [ -n "$U_ID" ] && case $U_ID in *[!0-9]*) echo "Invalid UID: $U_ID" >&2; return 1;; esac
    [ -n "$G_ID" ] && case $G_ID in *[!0-9]*) echo "Invalid GID: $G_ID" >&2; return 1;; esac

    # Grupo explícito
    if [ -n "$GNAME" ] && ! group_exists "$GNAME"; then
        log "Creating group $GNAME"
        groupadd ${G_ID:+-g "$G_ID"} "$GNAME" || return 1
        GROUP_DONE=1
    fi

    # User
    if [ -n "$USER" ]; then
        if [ -n "$GNAME" ] && [ "$GROUP_DONE" = 0 ] && ! group_exists "$GNAME"; then
            log "Creating a primary group $GNAME"
            groupadd ${G_ID:+-g "$G_ID"} "$GNAME" || return 1
        fi

        if ! user_exists "$USER" || [ "$MODE" = "--create" ]; then
            log "Creating user $USER"
            useradd -m \
                ${U_ID:+-u "$U_ID"} \
                ${COMMENT:+-c "$COMMENT"} \
                ${HOME:+-d "$HOME"} \
                ${SHELL:+-s "$SHELL"} \
                ${GNAME:+-g "$GNAME"} \
                ${GROUPS:+-G "$GROUPS"} \
                "$USER" || return 1
        else
            log "User $USER already exists"
        fi
    fi
}
# ---------------------------------------------------------
# get_package_display_name()
# Description: Returns the proper package name, applying multilib hacks.
# Parameters: part (optional)
# Returns: Proper package name in variable PKG_DISPLAY_NAME
# ---------------------------------------------------------
get_package_display_name()
{
    local part="$1"
    if [[ "$part" = "lib32" ]]; then
        PKG_DISPLAY_NAME="lib32-${pkgname}"
    else
        PKG_DISPLAY_NAME="${pkgname}${part:+-}${part}"
    fi
}
# ---------------------------------------------------------
# shooter_updates()
# Description: Generates schemas, updates icons, desktop, mime, etc.
# Parameters: updates (optional: "silent")
# ---------------------------------------------------------
shooter_updates() {
    local verbose=true update_count=0 update_errors=0
    local GLIB_SCHEMAS ICON_CACHE DESKTOP_DB MIME_DB MANDB FC_CACHE LDCONFIG GDK_PIXBUF

    # Detect commands
    GLIB_SCHEMAS=$(command -v glib-compile-schemas 2>/dev/null)
    ICON_CACHE=$(command -v gtk-update-icon-cache 2>/dev/null)
    DESKTOP_DB=$(command -v update-desktop-database 2>/dev/null)
    MIME_DB=$(command -v update-mime-database 2>/dev/null)
    MANDB=$(command -v mandb 2>/dev/null)
    FC_CACHE=$(command -v fc-cache 2>/dev/null)
    LDCONFIG=$(command -v ldconfig 2>/dev/null)
    GDK_PIXBUF=$(command -v gdk-pixbuf-query-loaders 2>/dev/null)

    [[ "$1" == "silent" ]] && verbose=false

    run_update() {
        local cmd="$1" desc="$2"; shift 2
        # Si no existe o no es ejecutable, salir silenciosamente
        [[ -z "$cmd" || ! -x "$cmd" ]] && return 0

        if $verbose; then
            echogn " --- Updating: "
            echo "${desc}"
        fi

        if "$cmd" "$@" &>/dev/null; then
            ((update_count++))
            $verbose && echog "\t** OK: Update completed successfully"
        else
            ((update_errors++))
            $verbose && echog "\t** Fail: Update failed"
        fi
    }

    # 1. Update GLib Schemas
    run_update "$GLIB_SCHEMAS" "$(echogn "schemas")" /usr/share/glib-2.0/schemas

    # 2. Update icon cache (Silent per theme, only existing dirs)
    if [[ -n "$ICON_CACHE" && -x "$ICON_CACHE" && -d /usr/share/icons ]]; then
        if $verbose; then
            echogn " --- Updating: "
            echogn "icons"
            echo
        fi
        for dir in /usr/share/icons/*/; do
            [[ -d "$dir" ]] && "$ICON_CACHE" -q -t -f "$dir" &>/dev/null
        done
        ((update_count++))
        $verbose && echog "\t** OK: Update completed successfully"
    fi

    # 3. Update desktop database
    run_update "$DESKTOP_DB" "$(echogn "desktop entries")" /usr/share/applications

    # 4. Update MIME types
    run_update "$MIME_DB" "$(echogn "MIME database")" /usr/share/mime

    # 5. Update manual database (if changes exist)
    if [[ -n "$MANDB" && -x "$MANDB" && -d /usr/share/man ]]; then
        if [[ -e /var/cache/man/index.db ]]; then
            if find /usr/share/man -newer /var/cache/man/index.db -type f -quit &>/dev/null; then
                run_update "$MANDB" "$(echogn "manual pages")" -q
            fi
        fi
    fi

    # 6. Update font cache (if changes exist)
    if [[ -n "$FC_CACHE" && -x "$FC_CACHE" && -d /usr/share/fonts ]]; then
        if [[ -d /var/cache/fontconfig ]]; then
            if find /usr/share/fonts -newer /var/cache/fontconfig -type f -quit &>/dev/null; then
                run_update "$FC_CACHE" "$(echogn "font cache")" -f
            fi
        fi
    fi

    # 7. Update library cache (if changes exist)
    if [[ -n "$LDCONFIG" && -x "$LDCONFIG" ]]; then
        if [[ -e /etc/ld.so.cache ]]; then
            if find /usr/lib /lib -newer /etc/ld.so.cache -type f -quit &>/dev/null; then
                run_update "$LDCONFIG" "$(echogn "shared libraries")"
            fi
        fi
    fi

    # 8. Update GDK Pixbuf loaders
    run_update "$GDK_PIXBUF" "$(echogn "gdk-pixbuf loaders")" --update-cache

    # Summary
    if $verbose; then
        if ((update_count > 0 || update_errors > 0)); then
            echog " - System updates completed"
            ((update_errors > 0)) && echog "   Some updates failed"
        else
            echog " - No updates were necessary"
        fi
    fi

    return $((update_errors > 0 ? 1 : 0))
}
# ---------------------------------------------------------
# print_background_title()
# Description: This prints a title.
# Parameters: message
# Returns: 0 in any way and title messages.
# ---------------------------------------------------------
print_background_title()
{
	# Get message text.
	MESSAGE="${1}"
	MESSAGE_CHARS=$(echog "${MESSAGE}" | wc -m)
	((MESSAGE_CHARS++))
	# Count colums of shell.
	SHELL_COLUMS=$(tput cols)
	TITLE_COLUMS=$((${SHELL_COLUMS} - ${MESSAGE_CHARS}))
	TITLE_COLUMS=$((${TITLE_COLUMS} / 2))
	for ((i=0;i<${TITLE_COLUMS};i++));
	do
		echo -n "="
	done
	echo -n " "
	echogn "${MESSAGE}"
	echo -n " "
	for ((i=0;i<${TITLE_COLUMS};i++));
	do
		echo -n "="
	done
	echo
	# Success.
	return 0
}
# ---------------------------------------------------------
# nhopkg_version()
# Description: Print nhopkg version. If user is in LFS based system, Nhopkg prints special message ;)
# Parameters: none
# Returns: 0 in any way and Nhopkg version.
# ---------------------------------------------------------
nhopkg_version()
{
	echo
	## Check if Nhopkg is running in LFS system ;-)
	if [[ -e "/etc/lfs-release" ]]; then
		echog "Great Work your LFS! ;-)"
	fi
	echogn "Nhopkg version"
	echo " ${NHOPKG_VERSION}"
	echo "Nhopkg  Copyright (C) 2008-2009  Jaime Gil de Sagredo Luna <jaimegildesagredo@gmail.com>"
	echo "Nhopkg  Copyright (C) 2009-2025  Carlos Sánchez <cargabsj175@gmail.com>"
	return 0
}
# ---------------------------------------------------------
# nhopkg_usage()
# Description: Shows the how-to usage Nhopkg.
# Parameters: none
# Returns: 0 in success and usage message.
# ---------------------------------------------------------
nhopkg_usage()
{
	echo
	echog "Usage: nhopkg [command] [options] package"
	echog "To see the help: nhopkg --help"
	return 0
}
# ---------------------------------------------------------
# nhopkg_usage_with_sudo()
# Description: Shows the how-to usage Nhopkg with sudo.
# Parameters: none
# Returns: 0 in success and usage message (with sudo).
# ---------------------------------------------------------
nhopkg_usage_with_sudo()
{
	echo
	echog "Usage: sudo nhopkg [command] [options] package"
	echog "To see the help: nhopkg --help"
	return 0
}
# ---------------------------------------------------------
# nhopkg_license()
# Description: Shows nhopkg's license (always will be software libre).
# Parameters: none
# Returns: 0 in success and license message.
# ---------------------------------------------------------
nhopkg_license()
{
	echo "Nhopkg  Copyright (C) 2008-2009  Jaime Gil de Sagredo Luna <projectnhoax@gmail.com>"
	echo "Nhopkg  Copyright (C) 2009-2025  Carlos Sánchez <cargabsj175@gmail.com>"
	echo
	echog "This program comes with ABSOLUTELY NO WARRANTY."
	echog "This is free software, and you are welcome to redistribute it under certain conditions; for details type nhopkg --license-all."
	return 0
}
# ---------------------------------------------------------
# nhopkg_help()
# Description: Shows the help of nhopkg.
# Parameters: none
# Returns: 0 in success and help pages.
# TODO: Add support to explain any command with --help command.
# ---------------------------------------------------------
nhopkg_help()
{
	nhopkg_usage_with_sudo
	echo
	echog "Examples:"
	echog " * Install binary package"
	echo "sudo nhopkg -i ${HOME}/gimp-3.0.4-n2025.linux-x86_64.nho"
	echog " * Show files on package."
	echo "nhopkg --show gimp-3.0.4-n2025"
	echo
	echog "Commands:"
	echog " -A, --add-to-repo\tIncrementally add one or more .nho packages to an existing repository."
	echog " -B, --backup\tCreates binary package from installed package."
	echog " -C, --super-build\tCompiles and installs source package from Git repo."
	echog " -G, --install-group\tInstalls binaries packages from a specified group from the repository."
	echog " -S, --super-install\tInstalls binary package form repository."
	echog " -U, --update\tUpdate repository database."
	echog " -X, --strip-binaries\tRemove debug symbols from installed binaries and libraries during installation (experimental)."
	echo
	echog " -b, --build\tCompiles and installs source package."
	echog " -d, --dios\tSame as -S, --super-install."
	echog " -e, --clean\tRemove cached data."
	echog " -g, --create-repo\tCreates software repository on selected directory."
	echog " -i, --install\tInstalls binary package."
	echog " -k, --check\tChecks if installed package is correct."
	echog " -l, --list\tLists installed packages."
	echog " -n, --info\tShows package details."
	echog " -r, --remove\tRemoves package installed by Nhopkg."
	echog " -s, --search\tSearch for package and its details."
	echog " -t, --list-repo\tLists packages on repository and their details."
	echog " -u, --update-db\tUpdate Nhopkg database."
	echog " -w, --show\tShows package files."
	echog " -x, --update-shooters\tUpdates all system data and schemas."
	echog " -y, --upgrade\tUpdates all installed packages."
	echog " --license-all\tShows complete Nhopkg license."
	echog " --license\tShows Nhopkg license."
	echog " --version\tShows Nhopkg version."
	echog " -h, --help\tShows this help page."
	echo
	echog "Options:"
	echog " --repo-dir <dir>\tRepository root directory (used with --add-to-repo)."
	echog " --force-check-arch\tForce check architecture."
	echog " --force-check-deps\tForce check dependencies."
	echog " --force-check-sha256\tForce check SHA256 Sum."
	echog " --no-check-arch\tDon't check architecture."
	echog " --no-check-deps\tDon't check dependencies."
	echog " --no-check-sha256\tDon't check SHA256 Sum."
	echog " --sign-package\tSign the binary package when building it."
	echog " --no-sign-package\tSkip the package signature."
	echog " --verify-package-signature\tVerify the GPG signature of the package before installing it."
	echog " --no-verify-package-signature\tSkip signature verification."
	echog " --purge\tRemove inverse dependencies of package."
	echog " --root\tSets install root."
	echog " -R, --recursive\tNhopkg works recursively."
	echog " -o, --output\tWrite an output log."
	echog " -v, --verbose\tVerbose operations."
	echog " --\tStop parssing arguments."
	return 0
}
# ---------------------------------------------------------
# check_if_running()
# Description: Check if Nhopkg is already running.
# Parameters: none
# Returns: NHOPKG_LECHE variable (1 if running and 0 if not).
# ---------------------------------------------------------
check_if_running()
{
	declare -x NHOPKG_LECHE
	NHOPKG_LECHE=0
	while [[ -e "${NHOPKG_LOCKFILE}" ]];
	do
		echo
		echog "Nhopkg is already in use..."
		OLDPID=$(cat "${NHOPKG_LOCKFILE}")
		if [[ $(ps -p "${OLDPID}" | grep "nhopkg") ]]; then
			NHOPKG_LECHE=1
		else
			echog "Exist an older lock file, but seems that is not in use..."
			if [[ -w "${NHOPKG_LOCKFILE}" ]]; then
				echo $$ > "${NHOPKG_LOCKFILE}"
				NHOPKG_LECHE=0
				return 0
			else
				echog " * You can't rewrite lock file."
				# This varible is to be used with front ends.
				NHOPKG_LECHE=1
				# Nhopkg can't make other thing, exits.
				exit 1
			fi
		fi
		# Every 5 seconds Nhopkg check if there are other Nhopkg running.
		sleep 5
	done
	echo $$ > "${NHOPKG_LOCKFILE}"
	return 0
}
# ---------------------------------------------------------
# get_pwd_dir()
# Description: Sets directory name and its owner of directory where Nhopkg is running.
# Parameters: none
# Returns: CWD and DIROWNER variables. Return 0 if success.
# ---------------------------------------------------------
get_pwd_dir()
{
	if [[ -d $(pwd) ]]; then
		CWD=$(pwd)
	else
		CWD="/tmp"
	fi
	# Get owner of dir.
	DIROWNER=$(ls -n "${CWD}" | tail -1 | awk '{print $3":"$4}')
	if [[ -z "${DIROWNER}" ]] || [[ "${DIROWNER}" = ":" ]]; then
		# By default 0:0 (root:root).
		DIROWNER="0:0"
	fi
	return 0
}
# ---------------------------------------------------------
# check_if_root_uid()
# Description: Check if Nhopkg is running as root.
# Parameters: none
# Returns: exit 1 if not root. Return 0 if success.
# ---------------------------------------------------------
check_if_root_uid()
{
	if [[ "${UID}" != "0" ]]; then
		echog "To run Nhopkg you need have root powers."
		exit 1
	fi
	return 0
}
# ---------------------------------------------------------
# make_tmp_dir()
# Description: Creates secure temporal directory for nhopkg.
# Parameters: none
# Returns: NHOPKG_TMPDIR variable (is temporal directory). Return 0 if success.
# ---------------------------------------------------------
make_tmp_dir()
{
	NHOPKG_TMPDIR=$(mktemp -udt "${TEMPLATE_TMPDIR}" -p "${TMPDIR}")
	mkdir -p "${NHOPKG_TMPDIR}"
	check_if_ok " * Unable to create temporary directory."
	return 0
}
# ---------------------------------------------------------
# check_if_ok()
# Description: Checks that the previous command was ok. If fails exits with error.
# Parameters: none
# Returns: Return 0 if success. Error message and exit 1 if error.
# ---------------------------------------------------------
check_if_ok() {
	if [[ "${?}" != "0" ]]; then
		NHO_MSG_ERROR="${1}"
		if [[ -n "${NHO_MSG_ERROR}" ]]; then			
			echog "${NHO_MSG_ERROR}" >&2
		fi
		# Clean up and exits.
		cleanup_tmp_dir
		exit 1
	fi
	return 0
}
# ---------------------------------------------------------
# update_local_db()
# Description: Update nhopkg files database.
# Parameters: none
# Returns: Return 0 if success.
# ---------------------------------------------------------
update_local_db()
{
	echogn " --- Updating database:"
	echo " ${NHOPKG_DB}"
	updatedb --output="${NHOPKG_DB}" --prunepaths="${NO_DIRS_IN_DB}"
	check_if_ok " * Fails to update database."
	return 0
}
# ---------------------------------------------------------
# nhopkg_ask_follow()
# Description: Ask if continue or not. By default NO.
# Parameters: none
# Returns: Return 0 if yes and 1 if no.
# ---------------------------------------------------------
nhopkg_ask_follow()
{
	if [[ "${NHOPKG_RECURSIVE}" = "yes" ]]; then
		# If you set recursive mode don't ask. By default YES (0).
		return 0
	fi
	echogn "Do you want to continue?[yes/NO]: "
	read -e follow
	if [[ -z "${follow}" ]]; then
		# Don't continue, return 1.
		return 1
	fi
	case "${follow}" in
		$(echog "yes"))
			# Continue, return 0.
			return 0
		;;
		$(echog "no"))
			# Don't continue, return 1.
			return 1
		;;
		*)
			nhopkg_ask_follow
		;;
	esac
}
#======================================1
# Clean nhopkg functions
#======================================1
## Funtion cleanup_tmp_dir(). Clean up temporal directory recursively.
# Usage: cleanup_tmp_dir (without arguments)
cleanup_tmp_dir()
{
	if [[ -d "${NHOPKG_TMPDIR}" ]]; then
		echog " --- Deleting temporary directory."
		# Force and recursive mode.
		rm -Rf "${NHOPKG_TMPDIR}"
	fi
}
## Funtion cleanup_all(). Clean up nhopkg.
# Usage: cleanup_all (without arguments)
cleanup_all()
{
	if [[ -f "${NHOPKG_LOCKFILE}" ]]; then
		rm -f "${NHOPKG_LOCKFILE}"
		# If tmpdir exist, delete it.
		cleanup_tmp_dir
	fi
}
## cleanup_build_dir(). Clean up nhopkg build directory.
# Usage: cleanup_build_dir (without arguments)
cleanup_build_dir()
{
	if [[ -d "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}" ]]; then
		echog "Compilation directory will be removed from your system."
		nhopkg_ask_follow
		case "${?}" in
			0)
				echogn " --- Deleting"
				echo " ${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}."
				rm -Rf "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}"
			;;
			1)
				echo -n " --- ${NHOPKG_BUILDIR}/${pkgname}-${pkgversion} "
				echog "will not be deleted."
			;;
		esac
	fi
}
#================================2
# Packages nhopkg functions
#================================2
## check_if_exist_local_package(). Check if selected package exists. If not exist fails.
# Usage: check_if_exist_local_package package (or file)
check_if_exist_local_package()
{
	if [[ ! -f "${1}" ]]; then
		echo -n "${1}: " >&2
		echog "The selected package doesn't exist." >&2
		exit 1
	fi
}
## get_basic_data(). Get basic data from package and checks it.
# Usage: get_basic_data package_info_file
# Gives: pkgname, pkgversion and pkgrevision variables.
get_basic_data()
{
	# Get basic package info.
	pkgname=$(grep "# Name:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgversion=$(grep "# Version:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgrevision=$(grep "# Release:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgdescription=$(grep "^# Description:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	# Checks that are all fields.
	if [[ -z "${pkgname}" ]] || [[ -z "${pkgversion}" ]]\
	|| [[ -z "${pkgrevision}" ]] || [[ -z "${pkgdescription}" ]]; then
		echog " * Failed to get package info." >&2
		exit 1
	fi
}
## get_nhoid_data(). Get data from package and checks that is a correct package.
# Usage: get_nhoid_data nhoid_file
# Gives: nhoid (local), pkgowner, pkgname, pkgversion, pkgrevision, pkglicense, pkggroup, pkgurl, pkgdescription, pkgsha256, pkgarch and pkginstalledsize variables.
get_nhoid_data()
{
	local nhoid=$(grep "^#%NHO-" "${1}" 2> /dev/null | sed -e 's@^#%NHO-@@')
	pkgowner=$(grep "^# Package Maintainer:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgname=$(grep "^# Name:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgversion=$(grep "^# Version:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgrevision=$(grep "^# Release:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkglicense=$(grep "^# License:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkggroup=$(grep "^# Group:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	# Get package repository (repository where the package will be hosted.)
	pkgrepo=$(grep "^# Repository:" "${1}" 2>/dev/null | awk -F'\t' '{print $2}')
	# Backward compatibility (If not present, assume it is "extra")
	pkgrepo="${pkgrepo:-extra}"
	pkgurl=$(grep "^# Url:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgdescription=$(grep "^# Description:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgsha256=$(grep -a "^# SHA256:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgarch=$(grep "^# Arch:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkgos=$(grep "^# OS:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkginstalledsize=$(grep "^# Installed-Size:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}' | awk '{print $1}')
    # Source from URL (git or tarball)
	pkgsrcurl=$(grep "^# Packageurl:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	pkggitref=$(grep "^# Packageref:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	# Set split variable
	SPLITPACKAGE=$(grep "^# Splitpackage:" "${1}" 2> /dev/null | awk -F'\t' '{print $2}')
	# If there are subpackages, look for specific descriptions
	if [[ -n "$SPLITPACKAGE" ]]; then
		for part in $SPLITPACKAGE; do
			local desc_key="^# Description_${part}:"
			local part_desc=$(grep "$desc_key" "$1" | awk -F'\t' '{print $2}')
    # If you don't have a specific description, use the general + note
			if [[ -z "$part_desc" ]]; then
				part_desc="${pkgdescription} (${part} files.)"
			fi
    # Create dynamic variable: ex. pkgdescription_dev, pkgdescription_docs, etc.
			eval "pkgdescription_${part}=\"\$part_desc\""
		done
	fi
	# Checks that is a correct package.
	if [[ -z "${nhoid}" ]]; then
		echog " * The selected package is not valid." >&2
		# Clean and exits with error.
		cleanup_tmp_dir
		exit 1
	fi
	# Checks that is a package created in the same version.
	if [[ "${nhoid}" > "${NHOID_VERSION}" ]]; then
		echog "The selected package is created in newer version of Nhopkg."
		echog "Nhopkg is on development and can't use packages of other versions. We working on this."
		# Clean and exits with error.
		cleanup_tmp_dir
		exit 1
	elif [[ "${nhoid}" < "${NHOID_VERSION}" ]]; then
		echog "The selected package is created in older version of Nhopkg."
		echog "Nhopkg is on development and can't use packages of other versions. We working on this."
		# Clean and exits with error.
		cleanup_tmp_dir
		exit 1
	elif [[ "${nhoid}" != "${NHOID_VERSION}" ]]; then
		echogn "The selected package is created in other version of Nhopkg:"
		echo " ${nhoid}."
		echog "Nhopkg is on development and can't use packages of other versions. We working on this."
		# Clean and exits with error.
		cleanup_tmp_dir
		exit 1
	fi
	source "${1}" 2> /dev/null
	check_if_ok " * Unable to get data from package."
}
# ---------------------------------------------------------
# version_compare()
# Description: Compare two versions using sort -V.
# Parameters: ver1 op ver2  (ex: "1.9" ">=" "2.0")
# Returns: 0 if the comparison is true, 1 if it is false.
# ---------------------------------------------------------
version_compare() {
    local ver1="$1" op="$2" ver2="$3"
    case "$op" in
        "")
            # No operator → no version comparison
            return 0
            ;;
        "="|==)
            if [[ "$(printf '%s\n%s' "$ver1" "$ver2" | sort -V | head -n1)" == "$ver1" ]] &&
               [[ "$(printf '%s\n%s' "$ver1" "$ver2" | sort -V | tail -n1)" == "$ver1" ]]; then
                return 0
            else
                return 1
            fi
            ;;
        "!=")
            if version_compare "$ver1" "=" "$ver2"; then
                return 1
            else
                return 0
            fi
            ;;
        "<")
            if [[ "$(printf '%s\n%s' "$ver1" "$ver2" | sort -V | head -n1)" == "$ver1" ]] &&
               ! version_compare "$ver1" "=" "$ver2"; then
                return 0
            else
                return 1
            fi
            ;;
        "<=")
            if [[ "$(printf '%s\n%s' "$ver1" "$ver2" | sort -V | head -n1)" == "$ver1" ]]; then
                return 0
            else
                return 1
            fi
            ;;
        ">")
            if [[ "$(printf '%s\n%s' "$ver1" "$ver2" | sort -V | tail -n1)" == "$ver1" ]] &&
               ! version_compare "$ver1" "=" "$ver2"; then
                return 0
            else
                return 1
            fi
            ;;
        ">=")
            if [[ "$(printf '%s\n%s' "$ver1" "$ver2" | sort -V | tail -n1)" == "$ver1" ]]; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            # Unknown operator → we assume conflict
            return 1
            ;;
    esac
}
# ---------------------------------------------------------
# get_package_provides_and_conflicts()
# Description: Extract Provides and Conflicts from an nhoid file.
# Conflicts It may include operators: foo>=2.0, bar<1.5, etc.
# Returns: 
#   PROVIDES_LIST=(name1 name2 ...)
#   CONFLICTS_SPECS=(spec1 spec2 ...)  # ej: "foo>=2.0"
# ---------------------------------------------------------
get_package_provides_and_conflicts()
{
    local nhoid_file="$1"
    PROVIDES_LIST=()
    CONFLICTS_SPECS=()  # Now we save the complete string
    if [[ ! -f "${nhoid_file}" ]]; then
        return
    fi
    # Provides: names only
    while IFS= read -r line; do
        local value=$(echo "$line" | awk -F'\t' '{print $2}')
        if [[ -n "$value" ]]; then
            read -ra items <<< "$value"
            PROVIDES_LIST+=("${items[@]}")
        fi
    done < <(grep "^# Provides:" "${nhoid_file}" 2>/dev/null)

    # Conflicts: We saved the complete original chain
    while IFS= read -r line; do
        local value=$(echo "$line" | awk -F'\t' '{print $2}')
        if [[ -n "$value" ]]; then
            read -ra items <<< "$value"
            CONFLICTS_SPECS+=("${items[@]}")
        fi
    done < <(grep "^# Conflicts:" "${nhoid_file}" 2>/dev/null)
}
# ---------------------------------------------------------
# check_package_conflicts()
# Description: Check for conflicts with version operator support.
# Sets global: REPLACES_PACKAGE (if a valid replacement exists)
# ---------------------------------------------------------
check_package_conflicts()
{
    local nhoid_file="$1"
    local new_pkgname new_pkgversion new_pkgrevision
    get_basic_data "${nhoid_file}"
    new_pkgname="$pkgname"
    new_pkgversion="$pkgversion"
    new_pkgrevision="$pkgrevision"
    get_package_provides_and_conflicts "${nhoid_file}"

    if [[ ${#CONFLICTS_SPECS[@]} -eq 0 ]]; then
        unset REPLACES_PACKAGE
        return 0
    fi

    get_list_installed_packages
    echog " - Checking for conflicts..."

    unset REPLACES_PACKAGE

    for conflict_spec in "${CONFLICTS_SPECS[@]}"; do
        # Parse: name, operator, version
        local name op ver
        if [[ "$conflict_spec" == *"="* ]] || [[ "$conflict_spec" == *"<"* ]] || [[ "$conflict_spec" == *">"* ]] || [[ "$conflict_spec" == *"!"* ]]; then
            # Extract name (first alphanumeric part)
            name="${conflict_spec%%[<>=!]*}"
            local rest="${conflict_spec#"$name"}"
            # Normalize == → =
            rest="${rest//==/=}"
            # Determine operator
            if [[ "$rest" == "="* ]]; then
                op="="
                ver="${rest#=}"
            elif [[ "$rest" == "!="* ]]; then
                op="!="
                ver="${rest#!}"
            elif [[ "$rest" == ">="* ]]; then
                op=">="
                ver="${rest#>=}"
            elif [[ "$rest" == "<="* ]]; then
                op="<="
                ver="${rest#<=}"
            elif [[ "$rest" == ">"* ]]; then
                op=">"
                ver="${rest#>}"
            elif [[ "$rest" == "<"* ]]; then
                op="<"
                ver="${rest#<}"
            else
                name="$conflict_spec"
                op=""
                ver=""
            fi
            name="${name// /}"
            ver="${ver// /}"
        else
            name="$conflict_spec"
            op=""
            ver=""
        fi

        # 1. Search for installed package with exact name
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${name}" ]]; then
            # Does the new package provide it? → possible replacement
            if [[ " ${PROVIDES_LIST[@]} " == *" ${name} "* ]]; then
                echog " *** WARNING: ${new_pkgname} will REPLACE '${name}' (provides the same interface)."
                REPLACES_PACKAGE="${name}"
                continue
            fi

            # Compare version if necessary
            local inst_pkgname inst_pkgversion inst_pkgrevision
            get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${name}"
            inst_pkgversion="$pkgversion"
            inst_pkgrevision="$pkgrevision"
            local inst_full_ver="${inst_pkgversion}-${inst_pkgrevision}"

            # If there is an operator, compare
            if [[ -n "$op" ]]; then
                if version_compare "$inst_full_ver" "$op" "$ver"; then
                    echog " *** CONFLICT: ${new_pkgname} conflicts with installed '${name}' (${inst_full_ver}) due to version constraint '${conflict_spec}'."
                    cleanup_tmp_dir
                    exit 1
                fi
            else
                # No operator → name conflict
                echog " *** CONFLICT: Cannot install ${new_pkgname} because '${name}' is installed." >&2
                cleanup_tmp_dir
                exit 1
            fi
        fi

        # 2. Search in packages that *provide* this name
        for installed_pkg in "${installedpackages[@]}"; do
            if [[ "${installed_pkg}" == "${new_pkgname}"* ]]; then
                continue
            fi

            # Extract Provides from the installed package
            local installed_provides=()
            while IFS= read -r line; do
                local value=$(echo "$line" | awk -F'\t' '{print $2}')
                if [[ -n "$value" ]]; then
                    read -ra items <<< "$value"
                    installed_provides+=("${items[@]}")
                fi
            done < <(grep "^# Provides:" "${NHOPKG_LOCALSTATEDIR}/packages/${installed_pkg}" 2>/dev/null)

            for prov in "${installed_provides[@]}"; do
                if [[ "$prov" == "$name" ]]; then
                    # Compare version if there is an operator
                    if [[ -n "$op" ]]; then
                        # Get the full version of the package that provides
                        get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${installed_pkg}"
                        local prov_full_ver="${pkgversion}-${pkgrevision}"
                        if version_compare "$prov_full_ver" "$op" "$ver"; then
                            echog " *** CONFLICT: ${new_pkgname} conflicts with '${installed_pkg}' (provides '${name}' ${prov_full_ver}) due to '${conflict_spec}'."
                            cleanup_tmp_dir
                            exit 1
                        fi
                    else
                        echog " *** CONFLICT: Cannot install ${new_pkgname} because '${installed_pkg}' provides '${name}'." >&2
                        cleanup_tmp_dir
                        exit 1
                    fi
                fi
            done
        done
    done
}
## check_package_sha256sum(). Check sha256 of package.
# Usage: check_package_sha256sum (without arguments)
check_package_sha256sum()
{
    if [[ "${NHOPKG_CHECKSHA256}" != "yes" ]]; then
        return 0
    fi
    
    # If pkgsrcurl is defined and it's a Git repository, we don't check SHA256 here.
    # The verification does not apply because there is no tarball present.
    if [[ -n "${pkgsrcurl}" && ("${pkgsrcurl}" == git+* || "${pkgsrcurl}" == *".git"*) ]]; then
        echog " --- Skipping SHA256 check: Git repository detected"
        return 0
    fi
    
    # If pkgsrcurl is defined but it is a link to a tarball, we do not check here either.
    # The verification will occur in build_prepare() after downloading the tarball
    if [[ -n "${pkgsrcurl}" && "${pkgsrcurl}" != git+* && "${pkgsrcurl}" != *".git"* ]]; then
        echog " --- Deferring SHA256 check: Tarball will be downloaded later"
        return 0
    fi
    
    # Check if pkgsha256 is defined and not empty
    if [[ -z "${pkgsha256}" ]]; then
        echog " *** ERROR: SHA256 checksum not defined for package" >&2
        echog "     ${pkgname}-${pkgversion}-${pkgrevision}" >&2
        echog "     This is required for local source packages." >&2
        echog "     Please define pkgsha256 in your .srcnho package." >&2
        cleanup_tmp_dir
        exit 1
    fi
    
    if [[ "${VERBOSE_MODE}" = "yes" ]]; then
        echogn " --- Checking SHA256 Sum for"
        echo " ${pkgname}-${pkgversion}-${pkgrevision}"
    fi
    cd "${NHOPKG_TMPDIR}"
    echo "${pkgsha256}" | sha256sum -c &> /dev/null
    check_if_ok " *** SHA256 checksum of package did not match."
    cd "${CWD}"
}
## check_package_arch(). Check architecture of package and compare it with the system.
# Usage: check_package_arch (without arguments)
check_package_arch()
{
	if [[ "${NHOPKG_CHECKARCH}" != "yes" ]]; then
		return 0
	fi
	if [[ "${VERBOSE_MODE}" = "yes" ]]; then
		echogn " --- Checking package arch for"
		echo " ${pkgname}-${pkgversion}-${pkgrevision}"
	fi
	HOST_ARCH=$(uname -m)
	# Check arch of given package.
	for arch in ${pkgarch};
	do
		case "${arch}" in
			noarch|all|any)
				# Package no have specific architecture.
				VALID_ARCH="yes"
				break
			;;
			$HOST_ARCH)
				# Check for host arch.
				VALID_ARCH="yes"
				break
			;;
			i?86)
				# Checking for ix86 architectures.
				xarch=$(echo "${arch}" | sed -e 's/i//' -e 's/86//')
                xHOST_ARCH=$(echo "${HOST_ARCH}" | sed -e 's/i//' -e 's/86//')
				# Check if xHOST_ARCH is larger than xarch
				if (( "${xHOST_ARCH}" > "${xarch}" )); then
					VALID_ARCH="yes"
					break
				fi
			;;
			*)
				# No valid arch.
				continue
			;;
		esac
	done
	if [[ "${VALID_ARCH}" != "yes" ]]; then
		echog " *** Architecture of package is not valid." >&2
		echogn " --- This package can be installed on the next system:"
		echo " ${pkgarch}"
		# Clean and exits with error.
		cleanup_tmp_dir
		exit 1
	fi
}
## check_if_installed_package(). Checks if package is already installed in the system.
# Usage: check_if_installed_package (without arguments)
check_if_installed_package()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
	if [[ -z "${part}" ]]; then
	part=""
	fi
	get_package_display_name "$part"

	# Checks that exist other versión of package.
	if [[ ! -f "${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}" ]]; then
		return 0
	fi
	# Get data from old package.
	local newpkgname newpkgversion newpkgrevision
	newpkgname="${PKG_DISPLAY_NAME}"
	newpkgversion="${pkgversion}"
	newpkgrevision="${pkgrevision}"
	local pkgname pkgversion pkgrevision
	get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${newpkgname}"
	# Compare package names.
	if [[ "${pkgname}" == "${newpkgname}" ]]; then
		# Compare package versions.
		if [[ "${pkgversion}" < "${newpkgversion}" ]]; then
			echo -en "${BOLD}"
			echo -n "${pkgname} "
			echo -en "${NORMAL}"
			echog "is installed in your system, but is deprecated. Package will be UPDATE."
			nhopkg_ask_follow
		elif [[ "${pkgversion}" == "${newpkgversion}" ]]; then
			if [[ "${pkgrevision}" < "${newpkgrevision}" ]]; then
				echo -en "${BOLD}"
				echo -n "${pkgname} "
				echo -en "${NORMAL}"
				echog "is installed in your system, but is deprecated. Package will be UPDATE."
				nhopkg_ask_follow
			elif [[ "${pkgrevision}" > "${newpkgrevision}" ]]; then
				echo -en "${BOLD}"
				echo -n "${pkgname} "
				echo -en "${NORMAL}"
				echog "is installed in your system and is newer. Package will be DOWNGRADE."
				nhopkg_ask_follow
			else
				echo -en "${BOLD}"
				echo -n "${pkgname} "
				echo -en "${NORMAL}"
				echog "is already installed in your system. Package will be REINSTALL."
				nhopkg_ask_follow
			fi
		elif  [[ "${pkgversion}" > "${newpkgversion}" ]]; then
			echo -en "${BOLD}"
			echo -n "${pkgname} "
			echo -en "${NORMAL}"
			echog "is installed in your system and is newer. Package will be DOWNGRADE."
			nhopkg_ask_follow
		fi
	fi
	# If NO is selected exits.
	check_if_ok " * Package will not be installed."
	# If YES is selected remove old package.
	remove_package
	remove_package_config_files
}
#======================================3
# Dependencies tracking nhopkg functions
#======================================3
# ---------------------------------------------------------
# resolve_package_by_name()
# Description: Given a package spec (e.g., "gd", "gd>=1.0", "gd<2.0"),
# returns the full path to the installed package metadata file if found and valid.
# Supports "Provides:" declarations in other packages.
# Parameters: package_spec (e.g., "gd", "gd>=1.0", "libfoo!=3.1")
# Returns: Full path to package file in ${NHOPKG_LOCALSTATEDIR}/packages/, or empty if not found/invalid.
# ---------------------------------------------------------
resolve_package_by_name() {
    local spec="$1"
    local name op min_version best_match best_ver

    # Parse operator and version
    if [[ "$spec" == *"="* ]] || [[ "$spec" == *"<"* ]] || [[ "$spec" == *">"* ]] || [[ "$spec" == *"!"* ]]; then
        name="${spec%%[<>=!]*}"
        local rest="${spec#"$name"}"
        rest="${rest//==/=}"
        if [[ "$rest" == "="* ]]; then
            op="="
            min_version="${rest#=}"
        elif [[ "$rest" == "!="* ]]; then
            op="!="
            min_version="${rest#!}"
        elif [[ "$rest" == ">="* ]]; then
            op=">="
            min_version="${rest#>=}"
        elif [[ "$rest" == "<="* ]]; then
            op="<="
            min_version="${rest#<=}"
        elif [[ "$rest" == ">"* ]]; then
            op=">"
            min_version="${rest#>}"
        elif [[ "$rest" == "<"* ]]; then
            op="<"
            min_version="${rest#<}"
        else
            name="$spec"
            op=""
            min_version=""
        fi
        name="${name// /}"
        min_version="${min_version// /}"
    else
        name="$spec"
        op=""
        min_version=""
    fi

    # === 1. Search by exact package name ===
    local candidates=()
    while IFS= read -r -d '' pkg; do
        local basename_pkg=$(basename "$pkg")
        case "$basename_pkg" in
            "$name")
                candidates+=("$pkg")
                ;;
            "$name"-[0-9]*)
                # Version starts with number → valid
                candidates+=("$pkg")
                ;;
            "$name"-[0-9]*-[a-zA-Z0-9]*)
                # Version and release → valid
                candidates+=("$pkg")
                ;;
        esac
    done < <(find "${NHOPKG_LOCALSTATEDIR}/packages/" -maxdepth 1 -type f -name "${name}*" -print0 2>/dev/null)

    # Validate candidates by internal name and version
    for pkgfile in "${candidates[@]}"; do
        local internal_name
        internal_name=$(grep "^# Name:" "$pkgfile" 2>/dev/null | awk -F'\t' '{print $2}')
        if [[ "$internal_name" != "$name" ]]; then
            continue
        fi

        local basename_pkg=$(basename "$pkgfile")
        local ver_rev="${basename_pkg#${name}-}"
        if [[ "$basename_pkg" == "$name" ]]; then
            ver_rev="0"
        fi

        # Compare version if there is an operator
        if [[ -n "$op" ]]; then
            if ! version_compare "$ver_rev" "$op" "$min_version"; then
                continue
            fi
        fi

        # Save best match (highest version)
        if [[ -z "$best_ver" ]] || [[ "$(printf '%s\n%s' "$best_ver" "$ver_rev" | sort -V | head -n1)" == "$best_ver" ]]; then
            best_ver="$ver_rev"
            best_match="$pkgfile"
        fi
    done

    # === 2. If not found, search in packages that "Provide" this name ===
    if [[ -z "$best_match" ]]; then
        while IFS= read -r -d '' pkg; do
            [[ -L "$pkg" ]] && continue
            local provides_line
            provides_line=$(grep "^# Provides:" "$pkg" 2>/dev/null)
            if [[ -n "$provides_line" ]]; then
                local prov_name
                while IFS= read -r prov_name; do
                    prov_name=$(echo "$prov_name" | awk -F'\t' '{print $2}' | tr -s ' ' '\n')
                    while IFS= read -r p; do
                        if [[ -n "$p" && "$p" == "$name" ]]; then
                            local internal_name
                            internal_name=$(grep "^# Name:" "$pkg" 2>/dev/null | awk -F'\t' '{print $2}')
                            if [[ -n "$internal_name" ]]; then
                                local prov_ver_rev
                                local bn=$(basename "$pkg")
                                if [[ "$bn" == "$internal_name" ]]; then
                                    prov_ver_rev="0"
                                else
                                    prov_ver_rev="${bn#${internal_name}-}"
                                fi

                                # If there is an operator, verify against the provider's version.
                                if [[ -n "$op" ]]; then
                                    if version_compare "$prov_ver_rev" "$op" "$min_version"; then
                                        best_match="$pkg"
                                        break 3
                                    fi
                                else
                                    best_match="$pkg"
                                    break 3
                                fi
                            fi
                        fi
                    done <<< "$prov_name"
                done <<< "$provides_line"
            fi
        done < <(find "${NHOPKG_LOCALSTATEDIR}/packages/" -maxdepth 1 -type f -print0 2>/dev/null)
    fi

    if [[ -n "$best_match" ]]; then
        echo "$best_match"
        return 0
    else
        return 1
    fi
}
## Shared to check if a dependency package is in the repository.
# Usage: check_if_repository_package_common <array_name>
# where <array_name> is the name of the array to store packages (e.g., RCASEPACKAGES or ORCASEPACKAGES)
check_if_repository_package_common()
{
	local array_name="$1"
	local dep_spec="${FILE_DEP%% *}"
	local found=0
	local repo candidate match_pkg

	# If it's an absolute path → use file search (old behavior)
	if [[ "${dep_spec}" == /* ]]; then
		get_good_file_name "${dep_spec}"
		local MATCHPACKAGE=$(zstdgrep -l "${GOOD_FILE_NAME}$" "${NHOPKG_LOCALSTATEDIR}/repo/"*/files/*.zst 2>/dev/null | head -n1)
		if [[ -z "${MATCHPACKAGE}" ]]; then
			echo -n " *** ${dep_spec} " >&2
			echog "is not on repository." >&2
			cleanup_tmp_dir
			exit 1
		fi
		# Extract repo and filename
		local repo_dir=$(echo "${MATCHPACKAGE}" | sed -E 's@.*/repo/([^/]*)/files/.*@\1@')
		MATCHPACKAGE=$(basename "${MATCHPACKAGE}" .zst)
		pkgrepo="${repo_dir}"
	else
		# It's a package name (possibly with >=, etc.)
		local pkg_name="${dep_spec%%[<>=!]*}"
		if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
			NHOPKG_ACTIVE_REPOS="extra"
		fi

		for repo in ${NHOPKG_ACTIVE_REPOS}; do
			if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${pkg_name}" ]]; then
				MATCHPACKAGE="${pkg_name}"
				pkgrepo="${repo}"
				found=1
				break
			fi
			# Try with versioned packages
			candidate=$(find "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/" -maxdepth 1 -name "${pkg_name}-[0-9]*" -type f 2>/dev/null | sort -V | tail -1)
			if [[ -n "${candidate}" ]]; then
				MATCHPACKAGE=$(basename "${candidate}")
				pkgrepo="${repo}"
				found=1
				break
			fi
		done

		if [[ $found -eq 0 ]]; then
			echo -n " *** ${dep_spec} " >&2
			echog "is not on repository." >&2
			cleanup_tmp_dir
			exit 1
		fi
	fi

	# Add to array
	if [[ -n "${MATCHPACKAGE}" ]]; then
		local -a current_list
		eval "current_list=(\"\${${array_name}[@]}\")"
		local exists=0
		for item in "${current_list[@]}"; do
			if [[ "${item}" == "${MATCHPACKAGE}" ]]; then
				exists=1
				break
			fi
		done
		if [[ $exists -eq 0 ]]; then
			eval "${array_name}+=(\"\${MATCHPACKAGE}\")"
			# Recursively check deps of this package
			check_post_dependencies "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${MATCHPACKAGE}"
			check_optional_post_dependencies "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${MATCHPACKAGE}"
		fi
	fi
}
## check_if_repository_package(). Checks if dependency packages are on repository.
# Usage: check_if_repository_package (without arguments)
check_if_repository_package()
{
    check_if_repository_package_common "RCASEPACKAGES"
}

## check_if_repository_optional_package(). Checks if dependency (optional) packages are on repository.
# Usage: check_if_repository_optional_package (without arguments)
check_if_repository_optional_package()
{
    check_if_repository_package_common "ORCASEPACKAGES"
}
## check_dependencies(). Generic to check dependencies.
# Usage: check_dependencies file_to_check dep_type repo_check_func
# dep_type: The grep pattern to identify dependencies (e.g., "^# BuildDep:", "^# OptionalBuildDep:")
# repo_check_func: The to call for repository checks (e.g., check_if_repository_package)
check_dependencies()
{
    local file_to_check="$1"
    local dep_type="$2"
    local repo_check_func="$3"
    local pkgname pkgversion pkgrevision
    get_basic_data "${file_to_check}"
    local CASE_DEPS=$(grep "${dep_type}" "${file_to_check}" 2> /dev/null)
    if [[ -n "${CASE_DEPS}" ]]; then
        local IFS=$'\n'
        local buildeps
        for buildeps in ${CASE_DEPS}; do
            local IFS="${OLDIFS}"
            # Parse all fields by converting tabs to spaces and splitting
            read -r -a DEP_FIELDS <<< "$(echo "${buildeps}" | tr '\t' ' ')"
            # Remove empty elements (in case of leading/trailing/multiple tabs)
            DEP_FIELDS=(${DEP_FIELDS[@]})
            if (( ${#DEP_FIELDS[@]} < 2 )); then
                continue
            fi
            local NAME_DEP="${DEP_FIELDS[1]}"
            local FILE_DEP_LIST=()
            local FORMAT="new"
            if (( ${#DEP_FIELDS[@]} >= 3 )); then
                # Old format: fields 2+ are file paths
                FILE_DEP_LIST=("${DEP_FIELDS[@]:2}")
                FORMAT="old"
            else
                # New format: field 1 contains space-separated package names
                read -r -a FILE_DEP_LIST <<< "${NAME_DEP}"
                FORMAT="new"
            fi
            # Shows dependency for check.
            echogn " --- Processing Dependency:"
            echo -n " ${NAME_DEP} "
            echogn "for"
            echo " ${pkgname}-${pkgversion}-${pkgrevision}"
            # Check each dependency in the list
            local CHECK_FILE_DEP_NUM="0"
            local FILE_DEP_NUM="${#FILE_DEP_LIST[@]}"
            for CHECK_FILE_DEP in "${FILE_DEP_LIST[@]}"; do
                if [[ "${FORMAT}" == "old" ]]; then
                    # Old format: CHECK_FILE_DEP is a file path
                    if [[ "${CHECK_FILE_DEP}" == /* ]]; then
                        if [[ -f "${CHECK_FILE_DEP}" ]]; then
                            ((CHECK_FILE_DEP_NUM++))
                            if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                                echo -e "\t- $(basename "${CHECK_FILE_DEP}"): ${CHECK_FILE_DEP}"
                            fi
                        else
                            get_good_file_name "${CHECK_FILE_DEP}"
                            local LOCATE_DEPS=$(${BINLOCATE} -b -d "${NHOPKG_DB}" $(basename "${CHECK_FILE_DEP}") | grep "${GOOD_FILE_NAME}$")
                            if [[ -n "${LOCATE_DEPS}" ]]; then
                                (( CHECK_FILE_DEP_NUM++ ))
                                if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                                    echo -e "\t- $(basename "${CHECK_FILE_DEP}"): $(echo -e "${LOCATE_DEPS}" | head -1)"
                                fi
                            else
                                if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                                    echo -e "\t- $(basename "${CHECK_FILE_DEP}"): Not Found!"
                                fi
                            fi
                        fi
                    else
                        # Fallback: treat as package name
                        if resolved_pkg=$(resolve_package_by_name "${CHECK_FILE_DEP}"); then
                            ((CHECK_FILE_DEP_NUM++))
                            if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                                echo -e "\t- ${CHECK_FILE_DEP}: found as $(basename "$resolved_pkg")"
                            fi
                        else
                            if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                                echo -e "\t- ${CHECK_FILE_DEP}: Not Found!"
                            fi
                        fi
                    fi
                else
                    # New format: CHECK_FILE_DEP is a package name (may include >=)
                    if resolved_pkg=$(resolve_package_by_name "${CHECK_FILE_DEP}"); then
                        ((CHECK_FILE_DEP_NUM++))
                        if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                            echo -e "\t- ${CHECK_FILE_DEP}: found as $(basename "$resolved_pkg")"
                        fi
                    else
                        if [[ "${VERBOSE_MODE}" = "yes" ]]; then
                            echo -e "\t- ${CHECK_FILE_DEP}: Not Found!"
                        fi
                    fi
                fi
            done
            local DEPS_PERCENT=$((CHECK_FILE_DEP_NUM * 100 / FILE_DEP_NUM))
            # Check if dependency is satisfied
            if (( FILE_DEP_NUM <= 5 )); then
                if (( CHECK_FILE_DEP_NUM == FILE_DEP_NUM )); then
                    echogn "\t** OK: Present"
                    echo " (${DEPS_PERCENT}%)"
                else
                    echogn "\t** FAIL: Present"
                    echo " (${DEPS_PERCENT}%)"
                    ${repo_check_func}
                fi
            else
                if (( CHECK_FILE_DEP_NUM >= (FILE_DEP_NUM - 2) )) && (( CHECK_FILE_DEP_NUM < (FILE_DEP_NUM + 1) )); then
                    echogn "\t** OK: Present"
                    echo " (${DEPS_PERCENT}%)"
                else
                    echogn "\t** FAIL: Present"
                    echo " (${DEPS_PERCENT}%)"
                    ${repo_check_func}
                fi
            fi
        done
    else
        echogn " *** No ${dep_type//[\^# :]/} dependencies found on package:" >&2
        echo " ${pkgname}-${pkgversion}-${pkgrevision}." >&2
    fi
    local IFS="${OLDIFS}"
}
## check_build_dependencies(). Checks required build dependencies.
# Usage: check_build_dependencies file_to_check
check_build_dependencies()
{
    check_dependencies "$1" "^# BuildDep:" "check_if_repository_package"
}

## check_optional_build_dependencies(). Checks optional build dependencies.
# Usage: check_optional_build_dependencies file_to_check
check_optional_build_dependencies()
{
    check_dependencies "$1" "^# OptionalBuildDep:" "check_if_repository_optional_package"
}

## check_post_dependencies(). Checks required dependencies.
# Usage: check_post_dependencies file_to_check
check_post_dependencies()
{
    check_dependencies "$1" "^# Dep(post):" "check_if_repository_package"
}

## check_optional_post_dependencies(). Checks optional dependencies.
# Usage: check_optional_post_dependencies file_to_check
check_optional_post_dependencies()
{
    check_dependencies "$1" "^# OptionalDep(post):" "check_if_repository_optional_package"
}
## downloadpackages(). Download packages from a given list.
# Usage: downloadpackages package_array_name
downloadpackages()
{
    local package_array_name="$1"
    local package
    for package in ${!package_array_name[*]}; do
        # Get data from package and download it.
        local pkgname=$(grep "^# Name:" "${NHOPKG_LOCALSTATEDIR}/repo/packages/${package}" 2> /dev/null | awk -F'\t' '{print $2}')
        local pkgversion=$(grep "^# Version:" "${NHOPKG_LOCALSTATEDIR}/repo/packages/${package}" 2> /dev/null | awk -F'\t' '{print $2}')
        local pkgrevision=$(grep "^# Release:" "${NHOPKG_LOCALSTATEDIR}/repo/packages/${package}" 2> /dev/null | awk -F'\t' '{print $2}')
        local pkgos=$(grep "^# OS:" "${NHOPKG_LOCALSTATEDIR}/repo/packages/${package}" 2> /dev/null | awk -F'\t' '{print $2}')
        local pkgarch=$(grep "^# Arch:" "${NHOPKG_LOCALSTATEDIR}/repo/packages/${package}" 2> /dev/null | awk -F'\t' '{print $2}')
        echogn " --- Downloading"
        echo " ${pkgname}-${pkgversion}-${pkgrevision}.nho"
        # Get repository URL
		local REPO_URL
		REPO_URL=$(get_repo_url "${pkgrepo}")
		# Download from that repository
		wget --https-only -cqt 3 -T 20 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${REPO_URL}/${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho"
        check_if_ok " *** Failed to download package. Please, retry."
        # Adds downloaded packages to list for install.
        if [[ -z "${DCASEPACKAGES[*]}" ]]; then
            DCASEPACKAGES=("${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho")
        else
            DCASEPACKAGES=(${DCASEPACKAGES[@]} "${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho")
        fi
    done
}
## downloadrequiredeps(). Download required dependencies.
# Usage: downloadrequiredeps (without arguments)
downloadrequiredeps()
{
    downloadpackages RCASEPACKAGES
}

## downloadoptdeps(). Download optional dependencies.
# Usage: downloadoptdeps (without arguments)
downloadoptdeps()
{
    downloadpackages ORCASEPACKAGES
}
## installdownloadedeps(). Installs downloaded dependencies.
# Usage: installdownloadedeps (without arguments)
# DEPRECATED: do not use in new code
installdownloadedeps()

{
	for DCASEPACKAGE in ${DCASEPACKAGES[*]};
	do
		check_if_exist_local_package "${NHOPKG_LOCALSTATEDIR}/cache/${DCASEPACKAGE}"
		# Get data from package.
		local NHOPKG_TMPDIR
		make_tmp_dir
		# Uncompress package.
		tar xfC "${NHOPKG_LOCALSTATEDIR}/cache/${DCASEPACKAGE}" "${NHOPKG_TMPDIR}" 2> /dev/null
		# Comprueba que no ha habido error al descomprimir
		check_if_ok " * Unable to uncompress package."
		# Get data from package.
		# Checks that is good package and get data from it.
		if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
			local pkgowner pkgname pkgversion pkgrevision pkglicense pkggroup pkgurl pkgdescription pkgsha256 pkgarch pkgos pkginstalledsize
			get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"
		else
			echog " * The selected package is not valid." >&2
			# Clean and exits with error.
			cleanup_tmp_dir
			exit 1
		fi
		## 3. Checks SHA256 sum and architecture.
		check_package_sha256sum
		check_package_arch
		## 3.5. Verify GPG signature (if enabled)
		verify_package_signature
		# Handle package replacement
		if [[ -n "${REPLACES_PACKAGE}" ]]; then
			remove_replaced_package "${REPLACES_PACKAGE}"
		fi
		## 6. Install binary package.
		bin_install
		## 7. Configure installation.
		bin_install_setting_up
		bin_install_create_config_files
		# 8. Clean up and exit.
		cleanup_tmp_dir
	done
}
## askforinstallrequiredeps(). Asks to user if wants to install required dependencies. If NO nhopkg exits.
# Usage: askforinstallrequiredeps (without arguments)
askforinstallrequiredeps()
{
	unset DCASEPACKAGES
	if [[ -z "${RCASEPACKAGES[0]}" ]]; then
		return 0
	fi
	# Asks for continue.
	echo -en "${BOLD}"
	echo -n "${pkgname}-${pkgversion}-${pkgrevision} "
	echo -en "${NORMAL}"
	if [[ -n "${RCASEPACKAGES[1]}" ]]; then
		echogn "needs the following dependencies:"
	else
		echogn "needs this dependency:"
	fi
	local IFS=,
	echo " ${RCASEPACKAGES[*]}."
	local IFS="${OLDIFS}"
	nhopkg_ask_follow
	check_if_ok " * Package will not be installed."
	Q_INSTALL_REQUIRED_DEPS="0"
}
## installrequiredeps(). Installs required dependencies from repos if aren't installed yet.
# Usage: installrequiredeps (without arguments)
installrequiredeps()
{
	# Check if install.
	if [[ "${Q_INSTALL_REQUIRED_DEPS}" != "0" ]]; then
		return 0
	fi
	# Download packages from repo.
	downloadrequiredeps
	# Installs downloaded packages.
	installdownloadedeps
	unset RCASEPACKAGES
}
## askforinstalloptdeps(). Asks to user if wants to install optional dependencies. If NO nhopkg continues.
# Usage: askforinstalloptdeps (without arguments)
askforinstalloptdeps()
{
	unset DCASEPACKAGES
	if [[ -z "${ORCASEPACKAGES[0]}" ]]; then
		return 0
	fi
	# Asks for continue.
	echo -en "${BOLD}"
	echo -n "${pkgname}-${pkgversion}-${pkgrevision} "
	echo -en "${NORMAL}"
	if [[ -n "${ORCASEPACKAGES[1]}" ]]; then
		echogn "needs the following optional dependencies:"
	
	else
		echogn "needs this optional dependency:"
	fi
	local IFS=,
	echo " ${ORCASEPACKAGES[*]}."
	local IFS="${OLDIFS}"
	nhopkg_ask_follow
	Q_INSTALL_OPT_DEPS="${?}"
}
## installoptdeps(). Installs optional dependencies from repos if aren't installed yet.
# Usage: installoptdeps (without arguments)
installoptdeps()
{
	# Check if install.
	if [[ "${Q_INSTALL_OPT_DEPS}" != "0" ]]; then
		return 0
	fi
	# Download packages from repo.
	downloadoptdeps
	# Installs downloaded packages.
	installdownloadedeps
	unset ORCASEPACKAGES
}
#======================================4
# Install (binary package) functions
#======================================4
## bin_install_progress(). Prints a progress bar for the installation process.
# Usage: bin_install_progress command (Ex: tar xvfP -) logfile tarfile (Ex: data.tar.zst) filename (Package name. Ex: ${pkgname}) installedsize (Ex: ${pkginstalledsize})
bin_install_progress()
{
	local COMMAND="${1}"
	local LOG_FILE="${2}"
	local TAR_FILE="${3}"
	local FILE_NAME="${4}"
	local INSTALLED_SIZE="${5}"
	SHELL_COLUMS=$(tput cols)
	UNTAR_SIZE=0
	BAR_WIDTH=$((${SHELL_COLUMS}-$(echo "${pkgname}-${pkgversion}-${pkgrevision}:" | wc -m)-$(echo "${INSTALLED_SIZE}" | wc -m)-25))
	MIN_BAR_WIDTH="5"
	if (( ${BAR_WIDTH} < ${MIN_BAR_WIDTH} )); then
		BAR_WIDTH="${MIN_BAR_WIDTH}"
	fi
	START_TIME=$(date -u +%s)
	(zstdcat ${TAR_FILE}) | (
	while (( ${UNTAR_SIZE} < ${INSTALLED_SIZE} ));
	do
		dd bs=512 count=2048 2>/dev/null # || return 1
		(( UNTAR_SIZE += 1024 ))
		if (( ${UNTAR_SIZE} > ${INSTALLED_SIZE} )); then
			UNTAR_SIZE=$INSTALLED_SIZE
		fi
		# Print title.
		printf "\r %-5s: " ${FILE_NAME} >&2
		# pPrint percentage.
		export PERCENT=$(( 100 * $UNTAR_SIZE / $INSTALLED_SIZE ))
		printf "%3d%% [" $PERCENT >&2
		# Print progress bar.
		PROGRESS_BAR=$(( $BAR_WIDTH * $UNTAR_SIZE / $INSTALLED_SIZE ))
		for i in $(seq 1 $PROGRESS_BAR);
		do
			printf "${PROGRESS_BAR_BEGIN}" >&2
		done
		if (( "${PERCENT}" < "100" )); then
			printf "${PROGRESS_BAR_END}" >&2
		else
			printf "${PROGRESS_BAR_BEGIN}" >&2
		fi
		for i in $(seq $PROGRESS_BAR $(( BAR_WIDTH-- )));
		do
			printf "${PROGRESS_BAR_EMPTY}" >&2
		done
		# Print size of file copied.
		printf -v size "%d kB" $UNTAR_SIZE
		printf "] %7s" "$size" >&2
		# Print ETA.
		ELAPSED_TIME=$(( $(date -u +%s) - $START_TIME ))
		REMAIN_TIME=$(( $INSTALLED_SIZE - $UNTAR_SIZE ))
		ETA_TIME=$(( ($ELAPSED_TIME * $REMAIN_TIME) / $UNTAR_SIZE + 1))
		# Get minutes and seconds
		ETA_TIME_MIN=$(( $ETA_TIME / 60 ))
		ETA_TIME_SEC=$(( $ETA_TIME % 60 ))
		printf " %02dm%02ds ETA" $ETA_TIME_MIN $ETA_TIME_SEC >&2
	done
	echo >&2
	) | ${COMMAND}  2>/dev/null > ${LOG_FILE}
}
# ---------------------------------------------------------
# verify_package_signature()
# Description: Verifies GPG signature of data.tar.zst using trusted keyring.
#              Auto-initializes the keyring if needed.
# Parameters: none
# Returns: 0 if OK or signature not required; exits on failure.
# ---------------------------------------------------------
verify_package_signature()
{
    if [[ "${NHOPKG_VERIFY_SIGNATURE}" != "yes" ]]; then
        return 0
    fi

    # --- Auto-setup trusted keyring if not initialized ---
    local TRUSTED_KEYS_DIR="${NHOPKG_TRUSTED_KEYS_DIR}"
    local DEFAULT_PUBKEY="${TRUSTED_KEYS_DIR}/nhopkg-repo.pub"

    if [[ ! -f "${TRUSTED_KEYS_DIR}/pubring.kbx" ]] && [[ -f "${DEFAULT_PUBKEY}" ]]; then
        mkdir -p "${TRUSTED_KEYS_DIR}"
        echog " --- Initializing trusted keyring..."
        if gpg --homedir "${TRUSTED_KEYS_DIR}" --import "${DEFAULT_PUBKEY}" &>/dev/null; then
            echog " --- Trusted keyring initialized."
        else
            echog " *** WARNING: Failed to initialize trusted keyring." >&2
        fi
    fi

    # --- Verify signature ---
    if [[ ! -f "${NHOPKG_TMPDIR}/signature.gpg" ]]; then
        echog " *** WARNING: Package is not signed." >&2
        if [[ "${NHOPKG_REQUIRE_SIGNATURE}" == "yes" ]]; then
            echog " *** Signature required. Aborting." >&2
            cleanup_tmp_dir
            exit 1
        fi
        return 0
    fi

    if [[ ! -f "${TRUSTED_KEYS_DIR}/pubring.kbx" ]]; then
        echog " *** ERROR: No trusted keyring found and no default key to import." >&2
        cleanup_tmp_dir
        exit 1
    fi

    echog " --- Verifying GPG signature..."
    if gpg --homedir "${TRUSTED_KEYS_DIR}" --batch --quiet --verify "${NHOPKG_TMPDIR}/signature.gpg" "${NHOPKG_TMPDIR}/data.tar.zst" 2>/dev/null; then
        echog " --- Signature OK."
    else
        echog " *** BAD SIGNATURE! Package may be tampered." >&2
        cleanup_tmp_dir
        exit 1
    fi
}
## Funtion bin_install(). Installs binary package form data.tar.zst.
# Usage: bin_install (without arguments)
bin_install()
{
	echogn " --- Installing"
	echo " ${pkgname}-${pkgversion}-${pkgrevision}"
	if [ -f "${NHOPKG_TMPDIR}/data.tar.zst" ] || [ -f "${NHOPKG_TMPDIR}/data.tar.xz" ] || [ -f "${NHOPKG_TMPDIR}/data.tar.bz2" ]; then
		# Checks if --root or --root= option are selected.
		if [[ "${USE_INSTALL_ROOT}" = "yes" ]]; then
		
			# --root mode: disable hook execution on host and prepare deferred postinstall script
			export NHOPKG_NO_EXEC_HOOKS=1
			export NHOPKG_ROOT="${INSTALL_ROOT}"
			POSTROOT="${NHOPKG_ROOT}/usr/local/bin"
			POSTSCRIPT="${POSTROOT}/postinstall.sh"
			
			bin_install_progress "tar xvfC - ${INSTALL_ROOT}" "${NHOPKG_TMPDIR}/.${pkgname}-${pkgversion}-${pkgrevision}-installed.log" "${NHOPKG_TMPDIR}/data.tar.*" "${pkgname}-${pkgversion}-${pkgrevision}" "${pkginstalledsize}"
			# Checks if all is good.
			check_if_ok " *** Failed to install package."
		else
			# Checks if data.tar.zst is preceded by / or not.
			if [[ $(zstdcat "${NHOPKG_TMPDIR}/data.tar.zst" 2> /dev/null | tar tfP - | head -1 | grep '^/') ]] || [[ $(tar JtfP "${NHOPKG_TMPDIR}/data.tar.xz" 2> /dev/null | head -1 | grep '^/') ]] || [[ $(tar jtfP "${NHOPKG_TMPDIR}/data.tar.bz2" 2> /dev/null | head -1 | grep '^/') ]]; then
				bin_install_progress "tar xvfP -" "${NHOPKG_TMPDIR}/.${pkgname}-${pkgversion}-${pkgrevision}-installed.log" "${NHOPKG_TMPDIR}/data.tar.*" "${pkgname}-${pkgversion}-${pkgrevision}" "${pkginstalledsize}"
				# Checks if all is good.
				check_if_ok " *** Failed to install package."
			else
				bin_install_progress "tar xvfC - /" "${NHOPKG_TMPDIR}/.${pkgname}-${pkgversion}-${pkgrevision}-installed.log" "${NHOPKG_TMPDIR}/data.tar.*" "${pkgname}-${pkgversion}-${pkgrevision}" "${pkginstalledsize}"
				# Checks if all is good.
				check_if_ok " *** Failed to install package."
			fi
		fi
	else
		echog " * The selected package is not valid." >&2
		# Clean up and exits.
		cleanup_tmp_dir
		exit 1
	fi
}
## bin_install_setting_up(). Configure installation from nhoid (npostinstall() function).
# Usage: bin_install_setting_up (without arguments)
bin_install_setting_up()
{
    local part="$1"
    [ -z "$part" ] && part=""

    get_package_display_name "$part"

    echogn " --- Setting up"
    echo " ${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}"

    # -------------------------------------------------
    # MODO --root → NO ejecutar, solo acumular
    # -------------------------------------------------
    if [ -n "$NHOPKG_NO_EXEC_HOOKS" ]; then
        append_npostinstall
        return 0
    fi

    # -------------------------------------------------
    # MODO NORMAL → ejecutar como siempre
    # -------------------------------------------------
    if [ "${VERBOSE_MODE}" = "yes" ]; then
        if declare -f npostinstall${part:+_}${part} >/dev/null 2>&1; then
            npostinstall${part:+_}${part}
        else
            noemptyfuncs
        fi
    else
        if declare -f npostinstall${part:+_}${part} >/dev/null 2>&1; then
            npostinstall${part:+_}${part} &> /dev/null
        else
            noemptyfuncs
        fi
    fi
}

## bin_install_create_config_files(). Creates config files of installed package ( on files/ and packages/ directories).
# Usage: bin_install_create_config_files (without arguments)
bin_install_create_config_files()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
	if [[ -z "${part}" ]]; then
		part=""
	fi
	get_package_display_name "$part"

	if [[ "${USE_INSTALL_ROOT}" = "yes" ]]; then
		mv "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/files/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" \
		2> /dev/null
		check_if_ok " *** Failed to install package."
		zstd --rm "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/files/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" 2> /dev/null
		check_if_ok " *** Failed to install package."
		# Touch info package file and make symlinks.
		grep '^#' "${NHOPKG_TMPDIR}/nhoid" > "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}"
		# Add npostremove() to nhoid.
		echo >> "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}"
		NPOSTREMOVE_FILE_NUM=$(grep -n "npostremove() {" "${NHOPKG_TMPDIR}/nhoid" | sed -e 's@:npostremove() {@@')
		tail -n +${NPOSTREMOVE_FILE_NUM} "${NHOPKG_TMPDIR}/nhoid" >> "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" \
		2> /dev/null
		check_if_ok " *** Failed to install package."
		ln -sf "${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}"
		ln -sf "${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" "${INSTALL_ROOT}${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}"
	else
		mv "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" "${NHOPKG_LOCALSTATEDIR}/files/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" \
		2> /dev/null
		check_if_ok " *** Failed to install package."
		zstd --rm "${NHOPKG_LOCALSTATEDIR}/files/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" 2> /dev/null
		check_if_ok " *** Failed to install package."
		# Touch info package file and make symlinks.
		grep '^#' "${NHOPKG_TMPDIR}/nhoid" > "${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}"
		# Add npostremove() to nhoid.
		echo >> "${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}"
		NPOSTREMOVE_FILE_NUM=$(grep -n "npostremove() {" "${NHOPKG_TMPDIR}/nhoid" | sed -e 's@:npostremove() {@@')
		tail -n +${NPOSTREMOVE_FILE_NUM} "${NHOPKG_TMPDIR}/nhoid" >> "${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" \
		2> /dev/null
		check_if_ok " *** Failed to install package."
		ln -sf "${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" "${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}"
		ln -sf "${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}" "${NHOPKG_LOCALSTATEDIR}/packages/${PKG_DISPLAY_NAME}-${pkgversion}"
	fi
}
#======================================5
# Super Install (binary package from repo) functions.
#======================================5
## getpackage(). Search selected package on repository.
# Usage: getpackage (without arguments)
# Gives: pkgname, pkgversion, pkgrevision, pkgrepo, pkgos, pkgarch variables.
getpackage()
{
    local found=0
    local repo candidate

    if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
        NHOPKG_ACTIVE_REPOS="extra"
    fi

    for repo in ${NHOPKG_ACTIVE_REPOS}; do
        # Try exact match
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${CASEPACKAGE}" ]]; then
            pkgname=$(grep "^# Name:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${CASEPACKAGE}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgversion=$(grep "^# Version:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${CASEPACKAGE}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgrevision=$(grep "^# Release:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${CASEPACKAGE}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgrepo="${repo}"
            pkgos=$(grep "^# OS:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${CASEPACKAGE}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgarch=$(grep "^# Arch:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${CASEPACKAGE}" 2>/dev/null | awk -F'\t' '{print $2}')
            found=1
            break
        fi

        # Try by versioned name (e.g., zsnes → zsnes-2.0.12-n2025)
        candidate=$(find "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/" -maxdepth 1 -name "${CASEPACKAGE}-[0-9]*" -type f 2>/dev/null | sort -V | tail -1)
        if [[ -n "${candidate}" ]]; then
            pkgname=$(grep "^# Name:" "${candidate}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgversion=$(grep "^# Version:" "${candidate}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgrevision=$(grep "^# Release:" "${candidate}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgrepo="${repo}"
            pkgos=$(grep "^# OS:" "${candidate}" 2>/dev/null | awk -F'\t' '{print $2}')
            pkgarch=$(grep "^# Arch:" "${candidate}" 2>/dev/null | awk -F'\t' '{print $2}')
            found=1
            break
        fi
    done

    if [[ $found -eq 0 ]]; then
        # Fallback: search via file list (old method)
        get_good_file_name "${CASEPACKAGE}"
        local MATCHPACKAGE=$(zstdgrep -l "${GOOD_FILE_NAME}$" "${NHOPKG_LOCALSTATEDIR}/repo/"*/files/*.zst 2>/dev/null | head -n1)
        if [[ -n "${MATCHPACKAGE}" ]]; then
            local repo_dir=$(echo "${MATCHPACKAGE}" | sed -E 's@.*/repo/([^/]*)/files/.*@\1@')
            local pkgfile=$(basename "${MATCHPACKAGE}" .zst)
            if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo_dir}/packages/${pkgfile}" ]]; then
                pkgname=$(grep "^# Name:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo_dir}/packages/${pkgfile}" 2>/dev/null | awk -F'\t' '{print $2}')
                pkgversion=$(grep "^# Version:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo_dir}/packages/${pkgfile}" 2>/dev/null | awk -F'\t' '{print $2}')
                pkgrevision=$(grep "^# Release:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo_dir}/packages/${pkgfile}" 2>/dev/null | awk -F'\t' '{print $2}')
                pkgrepo="${repo_dir}"
                pkgos=$(grep "^# OS:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo_dir}/packages/${pkgfile}" 2>/dev/null | awk -F'\t' '{print $2}')
                pkgarch=$(grep "^# Arch:" "${NHOPKG_LOCALSTATEDIR}/repo/${repo_dir}/packages/${pkgfile}" 2>/dev/null | awk -F'\t' '{print $2}')
                found=1
            fi
        fi
    fi

    if [[ $found -eq 0 ]]; then
        echo -n " *** ${CASEPACKAGE} " >&2
        echog "is not on repository." >&2
        exit 1
    fi

    # Validate essential fields
    if [[ -z "${pkgname}" ]] || [[ -z "${pkgversion}" ]] || [[ -z "${pkgrevision}" ]] || [[ -z "${pkgrepo}" ]]; then
        echo -n " *** ${CASEPACKAGE} " >&2
        echog "is not on repository." >&2
        exit 1
    fi

    # Set defaults if missing (shouldn't happen, but safe)
    pkgos="${pkgos:-$(uname -s | awk '{print tolower($1)}')}"
    pkgarch="${pkgarch:-$(uname -m)}"
}
## downloadpackage(). Downloads package to install.
# Usage: downloadpackage (without arguments)
# Gives: Downloaded package on cache/ directory.
downloadpackage()
{
	# pkgos and pkgarch are already set by getpackage()
	echogn " --- Downloading"
	echo " ${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho"
	# Get repository URL
	local REPO_URL
	REPO_URL=$(get_repo_url "${pkgrepo}")
	# Download from that repository
	wget --https-only -cqt 3 -T 20 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${REPO_URL}/${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho"
	check_if_ok " *** Failed to download package. Please, retry."
}
#======================================6
# Remove (packages) functions.
#======================================6
## remove_progress(). Prints a progress bar for remove process.
# Usage: remove_progress (without arguments)
remove_progress()
{
	((DELETED_FILES++))
	printf "\r %-5s: " "${pkgname}-${pkgversion}-${pkgrevision}" >&2
	# Print percentage.
	export PERCENT=$(( 100 * $DELETED_FILES / $TOTAL_FILES ))
	printf "%3d%% [" $PERCENT >&2
	# Print progress bar.
	PROGRESS_BAR=$(( $BAR_WIDTH * $DELETED_FILES / $TOTAL_FILES ))
	for i in $(seq 1 $PROGRESS_BAR);
	do
		printf "${PROGRESS_BAR_BEGIN}" >&2
	done
	if (( "${PERCENT}" < "100" )); then
		printf "${PROGRESS_BAR_END}" >&2
	else
		printf "${PROGRESS_BAR_BEGIN}" >&2
	fi
	for i in $(seq $PROGRESS_BAR $(( BAR_WIDTH-- )));
	do
		printf "${PROGRESS_BAR_EMPTY}" >&2
	done
	# Print size of file copied.
	printf "]" >&2
	# Print ETA.
	ELAPSED_TIME=$(( $(date -u +%s) - $START_TIME ))
	REMAIN_TIME=$(( $TOTAL_FILES - $DELETED_FILES ))
	ETA_TIME=$(( ($ELAPSED_TIME * $REMAIN_TIME) / $DELETED_FILES + 1))
	# Get minutes and seconds.
	ETA_TIME_MIN=$(( $ETA_TIME / 60 ))
	ETA_TIME_SEC=$(( $ETA_TIME % 60 ))
	printf " %02dm%02ds ETA" $ETA_TIME_MIN $ETA_TIME_SEC >&2
}
## check_inverse_dependencies(). Checks what packages are depending of other.
# Usage: check_inverse_dependencies (without arguments)
# Gives: INVERSEDEPS variable.
check_inverse_dependencies()
{
	for package in ${installedpackages[*]};
	do
		local IFS=$'\n'
		# No me interesan dependencias opcionales.
		for dependency in $(grep "^# Dep(post):" "${NHOPKG_LOCALSTATEDIR}/packages/${package}");
		do
			DEPFILES=$(echo "${dependency}" | awk -F'\t' '{print $3}')
			local IFS=" "
			for depfile in ${DEPFILES};
			do
				# Could fail.
				#RETURN=$(zstdgrep -c "${depfile#/*/*/}" "${NHOPKG_LOCALSTATEDIR}/files/${1}.zst")
				get_good_file_name "${depfile}"
				RETURN=$(zstdgrep -c "${GOOD_FILE_NAME}$" "${NHOPKG_LOCALSTATEDIR}/files/${1}.zst")
				if [[ "${RETURN}" != "0" ]]; then
					if [[ -z "${INVERSEDEPS[@]}" ]]; then
						INVERSEDEPS=("${package}")
						check_inverse_dependencies "${package}"
					else
						for d in ${INVERSEDEPS[*]};
						do
							if [[ "${d}" = "${package}" ]]; then
								local LECHE="1"
								break
							fi
						done
						if [[ "${LECHE}" != "1" ]]; then
							INVERSEDEPS=("${package}" "${INVERSEDEPS[@]}")
							check_inverse_dependencies "${package}"
						fi
					fi
					break
				fi
			done
		done
	done
}
## remove_package(). Remove all files from package.
# Usage: remove_package() (without arguments)
remove_package()
{
	# Progress Bar variables.
	TOTAL_FILES=$(zstdgrep -vc "^#" "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst")
	DELETED_FILES="0"
	SHELL_COLUMS=$(tput cols)
	BAR_WIDTH=$((${SHELL_COLUMS}-$(echo "${pkgname}-${pkgversion}-${pkgrevision}:" | wc -m)-22))
	MIN_BAR_WIDTH="5"
	export PERCENT
	if (( ${BAR_WIDTH} < ${MIN_BAR_WIDTH} )); then
		BAR_WIDTH="${MIN_BAR_WIDTH}"
	fi
	START_TIME=$(date -u +%s)
	for removefiles in $(zstdgrep -v "^#" "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst")
	do
		# Check that file begin with /.
		if  [[ $(echo "${removefiles}" | grep "^/") ]]; then
			removefiles="${removefiles}"
		else
			removefiles="/${removefiles}"
		fi
		if [[ -f "${removefiles}" ]]; then
			rm -f "${removefiles}"
			if [[ "${VERBOSE_MODE}" = "yes" ]]; then
				echo -n " > ${removefiles}: "
				if [ ! -f "${removefiles}" ]; then
					echog "file deleted."
				else
					echog "unable to delete file."
				fi
			else
				remove_progress
			fi
		elif [[ -d "${removefiles}" ]]; then
			rmdir --ignore-fail-on-non-empty "${removefiles}"
			if [[ "${VERBOSE_MODE}" = "yes" ]]; then
				echo -n " > ${removefiles}: "
				if [ ! -d "${removefiles}" ]; then
					echog "directory deleted."
				else
					echog "unable to delete directory."
				fi
			else
				remove_progress
			fi
		fi
	done
	# To end progress bar.
	echo >&2
}
## remove_package_all(). Removes all packages (selected package and its inverse dependencies).
# Usage: remove_package_all (without arguments)
remove_package_all()
{
	for package2delete in ${INVERSEDEPS[*]};
	do
		local pkgname=$(grep "# Name:" "${NHOPKG_LOCALSTATEDIR}/packages/${package2delete}" 2> /dev/null | awk -F'\t' '{print $2}')
		local pkgversion=$(grep "# Version:" "${NHOPKG_LOCALSTATEDIR}/packages/${package2delete}" 2> /dev/null | awk -F'\t' '{print $2}')
		local pkgrevision=$(grep "# Release:" "${NHOPKG_LOCALSTATEDIR}/packages/${package2delete}" 2> /dev/null | awk -F'\t' '{print $2}')
		source "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
		remove_package
		remove_package_config_files
	done
	# Configure desinstallation.
	if [ "${VERBOSE_MODE}" = "yes" ]; then
		npostremove		
	else
		npostremove 2> /dev/null		
	fi
	
}
## remove_package_config_files(). Remove configure files form removed package.
# Usage: remove_package_config_files (without arguments)
remove_package_config_files()
{
	# Remove configuration files.
	rm -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}"
	rm -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}"
	rm -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
	rm -f "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst"
}
# ---------------------------------------------------------
# remove_replaced_package()
# Description: Removes a package that is being replaced.
# Parameters: package_name (e.g., "sdl2")
# ---------------------------------------------------------
remove_replaced_package()
{
    local old_pkg="$1"
    if [[ ! -f "${NHOPKG_LOCALSTATEDIR}/packages/${old_pkg}" ]]; then
        return 0
    fi

    echogn " - Replacing ${old_pkg} with ${pkgname}..."
    nhopkg_ask_follow
    if [[ $? -ne 0 ]]; then
        echog " * Replacement cancelled." >&2
        cleanup_tmp_dir
        exit 1
    fi

    # Save current values
    local save_pkgname="$pkgname"
    local save_pkgversion="$pkgversion"
    local save_pkgrevision="$pkgrevision"

    # Load data from the old package
    get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${old_pkg}"

    # Delete it
    remove_package
    remove_package_config_files

    # Restore original values
    pkgname="$save_pkgname"
    pkgversion="$save_pkgversion"
    pkgrevision="$save_pkgrevision"
}
#======================================7
# Build (packages) functions.
#======================================7
# set_files_and_patches() is required by the functions build_prepare(), fetch_git_source() and fetch_tarball_source()
# it leaves all patches and other files ready to compile.
set_files_and_patches(){
	if compgen -G "${NHOPKG_TMPDIR}/*" > /dev/null; then
        echog " - Additional files in package (patches):"
        for patch in "${NHOPKG_TMPDIR}"/*; do
            [[ -f "${patch}" ]] || continue
            echo -e "\t> $(basename "${patch}")"
            mv "${patch}" "${NHOPKG_BUILDIR}/"
        done
    fi
}
## fetch_git_source() clones a Git repository and optionally checks out a reference (branch, tag, commit).
# Usage: fetch_git_source <git_url> [git_ref]
fetch_git_source() {
    local git_url="$1"
    local git_ref="$2"
    local build_dir="${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}"

    echog " - Cloning Git repository: ${git_url}"
    if [[ -n "${git_ref}" ]]; then
        echog "   Reference: ${git_ref}"
    fi

    # Make sure of the build directory
    mkdir -p "${build_dir}"

    # Detect if the repository already exists
    if [[ -d "${build_dir}/.git" ]]; then
        echog "   Repository already exists. Updating..."
        cd "${build_dir}" || return 1
        git fetch origin || return 1
        if [[ -n "${git_ref}" ]]; then
            git checkout "${git_ref}" || return 1
        fi
    else
        # Clone directly to the build directory
        if ! git clone "${git_url}" "${build_dir}"; then
            echog " * Failed to clone Git repository." >&2
            return 1
        fi
        cd "${build_dir}" || return 1
        if [[ -n "${git_ref}" ]]; then
            if ! git fetch --depth 1 origin "${git_ref}"; then
                echog " * Failed to fetch reference ${git_ref}." >&2
                return 1
            fi
            if ! git checkout "${git_ref}"; then
                echog " * Failed to checkout reference ${git_ref}." >&2
                return 1
            fi
        fi
    fi
    
    # Move patches or additional files to the build dir
    set_files_and_patches

    echog " - Source code ready for build."
    srcfile_found=true
    return 0
}
## fetch_tarball_source() downloads and unpacks a tarball (.tar.gz, .tar.xz, etc.) into the build directory.
# Usage: fetch_tarball_source <tarball_url>
fetch_tarball_source() {
    local tarball_url="$1"
    local tarball_file="${NHOPKG_TMPDIR}/$(basename "${tarball_url}")"
    # This only line creates early the expected directory; 
    # In some cases, the compressed filename is not ideal or is different from the compressed source.
    # Ex., capitalization and unusual version numbers (v1.x or libXext, etc)...
    # Ex., gd-*.tar.* is internally a directory named libgd-gd-*
    # Also adds support for the zip format. 
    # Ex., files as sqlite-src-*.zip uses bsdtar whith --strip-components.
	local build_dir="${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}"
    
    echog " - Downloading source tarball: ${tarball_url}"
    if wget --https-only -q "${tarball_url}" -O "${tarball_file}"; then
        echog " - Download completed: ${tarball_file}"
    else
        echog " * Failed to download tarball from ${tarball_url}" >&2
        return 1
    fi

    # Check checksum if defined
    # === Specific SHA256 verification for downloaded package ===
	if [[ "${NHOPKG_CHECKSHA256}" != "yes" ]]; then
		return 0
	fi
	if [[ "${VERBOSE_MODE}" = "yes" ]]; then
		echogn " --- Checking SHA256 Sum for downloaded"
		echo " ${pkgname}-${pkgversion}"
	fi
	cd "${NHOPKG_TMPDIR}"
	local downloaded_hash=$(sha256sum "${tarball_file}" | awk '{print $1}')
	local expected_hash=$(echo "${pkgsha256}" | awk '{print $1}')
	echo "${pkgsha256}" | sha256sum -c &> /dev/null
	check_if_ok " *** SHA256 checksum of package did not match.\n    Expected hash: ${expected_hash}\n    Downloaded hash: ${downloaded_hash}"
	cd "${CWD}"
    # === End of specific verification ===

    # Create build directory (package name + version)
	mkdir -p ${build_dir}

    # Unpacking according to the extension
    case "${tarball_file}" in
        *.tar.zst|*.tar.zst.*)
            zstdcat "${tarball_file}" | tar xf - -C "${build_dir}" --strip-components=1 ;;
        *.tar.xz|*.tar.xz.*|*.txz)
            tar xJf "${tarball_file}" -C "${build_dir}" --strip-components=1 ;;
        *.tar.bz2|*.tar.bz2.*|*.tbz2)
            tar xjf "${tarball_file}" -C "${build_dir}" --strip-components=1 ;;
        *.tar.gz|*.tar.gz.*|*.tgz)
            tar xzf "${tarball_file}" -C "${build_dir}" --strip-components=1 ;;
        *.tar)
            tar xf "${tarball_file}" -C "${build_dir}" --strip-components=1 ;;
        *.zip|*.zip.*)
            bsdtar xf "${tarball_file}" -C "${build_dir}" --strip-components=1 ;;
        *)
            echog " * Unsupported archive format: ${tarball_file}" >&2
            return 1
            ;;
    esac
    
    # Move patches or additional files to the build dir
    set_files_and_patches

    if [[ $? -eq 0 ]]; then
		echog " - Source extracted to ${build_dir}."
		# Prevent a copy of the *.tar.* file from being compressed into the final binary package
		# I have no idea why this happens xD
        rm -f "${tarball_file}"
        srcfile_found=true
        return 0
    else
        echog " * Failed to extract ${tarball_file}" >&2
        return 1
    fi
}
## build_prepare(). Prepares system to build package.
# Usage: build_prepare (without arguments)
build_prepare() {
    local srcfile_found=false
    mkdir -p "${NHOPKG_BUILDIR}"
    
    # === Check if nhoid exists before moving it ===
    if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
        # Hide nhoid file.
        mv "${NHOPKG_TMPDIR}/nhoid" "${NHOPKG_TMPDIR}/.nhoid" 2> /dev/null || true
        echog " - nhoid file prepared for build process."
    else
        echog " * ERROR: nhoid file not found in ${NHOPKG_TMPDIR}" >&2
        echog "   This is critical for the build process." >&2
        echog "   The nhoid should come from the .srcnho package." >&2
        return 1
    fi

    # 1. If there is pkgsrcurl, try Git or tarball
    if [[ -n "${pkgsrcurl}" ]]; then
        if [[ "${pkgsrcurl}" == git+* ]]; then
            local git_url="${pkgsrcurl#git+}"
            fetch_git_source "${git_url}" "${pkggitref}"
        elif [[ "${pkgsrcurl}" == *".git"* ]]; then
            fetch_git_source "${pkgsrcurl}" "${pkggitref}"
        else
            # We assume it's a tarball
            fetch_tarball_source "${pkgsrcurl}"
        fi
        return $(( srcfile_found == false ))
    fi

    # 2. Find local source files (original behavior)
    for ext in zst xz bz2 gz; do
        local srcfile="${NHOPKG_TMPDIR}/${pkgname}-${pkgversion}.tar.${ext}"
        if [[ -e "${srcfile}" ]]; then
            srcfile_found=true
            case "${ext}" in
                zst)
                    zstdcat "${srcfile}" | tar xfC - "${NHOPKG_BUILDIR}" &> /dev/null ;;
                xz)
                    tar xJf "${srcfile}" -C "${NHOPKG_BUILDIR}" &> /dev/null ;;
                bz2)
                    tar xjf "${srcfile}" -C "${NHOPKG_BUILDIR}" &> /dev/null ;;
                gz)
                    tar xzf "${srcfile}" -C "${NHOPKG_BUILDIR}" &> /dev/null ;;
            esac
            break
        fi
    done

    # 3. Check if anything was found
    if [[ "${srcfile_found}" = false ]]; then
        echog " * No source package found and no valid pkgsrcurl defined." >&2
        return 1
    fi

    # 4. Clean up temporary font files
    rm -f "${NHOPKG_TMPDIR}/${pkgname}-${pkgversion}.tar".*

    # 5. Move patches or additional files to the build dir
    set_files_and_patches

    return 0
}
## build_package(). Build package form nhoid functions.
# Usage: build_package (without arguments)
build_package()
{
    # Receive the optional $part argument
    local part="$1"
    
    # Go to build directory.
    cd "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}" || { echog " * Failed to change to build dir ${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}"; exit 1; }
    echogn " - Building"
    echo " ${pkgname}-${pkgversion}-${pkgrevision}"
    echog "This step may take some time depending of package and your system."
    
    # Gets date, hour, host and arch of compilation.
    BUILD_DATE=$(date +%s) # Unix format
    BUILD_HOST="$(uname -n)"
    BUILD_ARCH="$(uname -m)"
    PACKAGE_OS="$(uname -s | awk '{print tolower ($1)}')"
    
    # If $part is NOT empty, the if block is skipped (compilation)
    # If $part is empty, run the compilation normally
    if [ -z "$part" ]; then
        if [ "${VERBOSE_MODE}" = "yes" ]; then
            (nbuild || echo 1 > "${NHOPKG_TMPDIR}/.RETVAL") 2>&1 \
            | tee -a "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log"
        else
            (nbuild || echo 1 > "${NHOPKG_TMPDIR}/.RETVAL") &> "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log"
        fi
    fi
}
## check_build_package(). Checks if build step is all Ok.
# Usage: check_build_package (without arguments)
check_build_package()
{
	# First check is RETVAL file exist.
	if [[ ! -e "${NHOPKG_TMPDIR}/.RETVAL" ]]; then
		return 0
	fi
	if [[ $(cat "${NHOPKG_TMPDIR}/.RETVAL" 2> /dev/null) != "0" ]]; then
		echog " * Failed compilation!" >&2
		if [[ -f "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" ]]; then
			mv "${NHOPKG_BUILDIR}/${pkgname}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" "${CWD}"
			chown "${DIROWNER}" "${CWD}/${pkgname}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log"
			echogn " --- You can see compilation log on"
			echo " ${CWD}/${pkgname}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log"
		fi
		# Clean up and exits with error.
		cleanup_tmp_dir
		cleanup_build_dir
		exit 1
	fi
}
## build_package_install(). Install source package form nhoid functions.
# Usage: build_package_install (with/without split arguments)
build_package_install()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
	if [[ -z "${part}" ]]; then
		part=""
	fi
	get_package_display_name "$part"

	# Touch pre installation file.
	touch "${NHOPKG_TMPDIR}/.nho-preinstall${part:+-}${part}"
	echogn " - Installing"
	echo " ${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}"
	echog "This step may take some time depending of package and your system."
	# Sleep 3 seconds.
	sleep 3
	# Gets date and hour of installation.
	INSTALL_DATE=$(date +%s) # Unix format
	if [ "${VERBOSE_MODE}" = "yes" ]; then
		(ninstall${part:+_}${part} || echo 1 > "${NHOPKG_TMPDIR}/.RETVAL") 2>&1 \
		| tee -a "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log"
	else
		(ninstall${part:+_}${part} || echo 1 > "${NHOPKG_TMPDIR}/.RETVAL") &> "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log"
	fi
}
## check_build_package_install(). Checks if install step is all Ok.
# Usage: check_build_package_install (with/without split arguments)
check_build_package_install()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
	if [[ -z "${part}" ]]; then
		part=""
	fi
	get_package_display_name "$part"

	# First check is RETVAL file exist.
	if [[ ! -e "${NHOPKG_TMPDIR}/.RETVAL" ]]; then
		return 0
	fi
	if [[ $(cat "${NHOPKG_TMPDIR}/.RETVAL" 2> /dev/null) != "0" ]]; then
		echog " * Failed instalation!" >&2
		if [[ -f "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" ]]; then
			mv "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" "${CWD}"
			chown "${DIROWNER}" "${CWD}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log"
			echogn " --- You can see compilation log on"
			echo " ${CWD}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log"
		fi
		if [[ -f "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log" ]]; then
			mv "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log" "${CWD}"
			chown "${DIROWNER}" "${CWD}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log"
			echogn " --- You can see instalation log on"
			echo " ${CWD}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log"
		fi
		# Clean up and exits with error.
		cleanup_tmp_dir
		cleanup_build_dir
		exit 1
	fi
}
## build_save_log_files(). Save logs on logs/ directory and compress (zstd).
# Usage: build_save_log_files (with/without split arguments)
build_save_log_files()
{
    part="$1"  # Parameter for subpackages. If there is no part, we use the main package
    [ -z "$part" ] && part=""
    get_package_display_name "$part"

    LOGDIR="${NHOPKG_LOCALSTATEDIR}/logs"

    if [ -e "$LOGDIR" ] && [ ! -d "$LOGDIR" ]; then
        echog " --- Veryfing logs path"
        rm -f "$LOGDIR"
    fi

    mkdir -p "$LOGDIR"

    echogn " --- Saving logs on"
    echo " $LOGDIR"

    if [ -f "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log" ]; then
        mv "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log" "$LOGDIR/"
        zstd --rm "$LOGDIR/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-install-${INSTALL_DATE}.log" 2>/dev/null
    fi

    if [ -f "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" ]; then
        mv "${NHOPKG_BUILDIR}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" "$LOGDIR/"
        zstd --rm "$LOGDIR/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-build-${BUILD_DATE}.log" 2>/dev/null
    fi
}
## build_search_for_files(). Search for files installed by package.
# Usage: build_search_for_files (with/without split arguments)
build_search_for_files()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
	if [[ -z "${part}" ]]; then
		part=""
	fi
	get_package_display_name "$part"

	touch "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log"
	# Safely iterate FIND_DIRS (may contain spaces); parse into array by spaces.
	IFS=' ' read -r -a FIND_DIRS_ARRAY <<< "${FIND_DIRS:-}"
	for searchdir in "${FIND_DIRS_ARRAY[@]}"; do
		if [[ -z "${searchdir}" ]]; then
			continue
		fi
		if [[ -d "${searchdir}" ]]; then
			find -- "${searchdir}" -type f -cnewer "${NHOPKG_TMPDIR}/.nho-preinstall${part:+-}${part}" \
			>> "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log"
			find -- "${searchdir}" -type l -cnewer "${NHOPKG_TMPDIR}/.nho-preinstall${part:+-}${part}" \
			>> "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log"
		fi
	done
	# Delete NoUpgrade files.
	IFS=' ' read -r -a NOUPGRADE_ARRAY <<< "${NOUPGRADE_FILES:-}"
	for noupgrade in "${NOUPGRADE_ARRAY[@]}"; do
		if [[ -z "${noupgrade}" ]]; then
			continue
		fi
		if grep -- "${noupgrade}" "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" &>/dev/null; then
			while IFS= read -r noupgrade2; do
				# Remove exact matches lines.
				sed -e "s@^${noupgrade2}@@" -i "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" 2> /dev/null || true
				# Remove empty lines.
				sed -e '/^$/d' -i "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" 2> /dev/null || true
			done < <(grep -- "${noupgrade}" "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" || true)
		fi
	done
	# Check if files exists and gets package size.
	PACKAGE_SIZE=0
	while IFS= read -r casefile; do
		[[ -n "${casefile}" ]] || continue
		if [[ ! -e "${casefile}" ]]; then
			sed -e "s@^${casefile}@@" -i "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" 2> /dev/null || true
			sed -e '/^$/d' -i "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" 2> /dev/null || true
		elif [[ -f "${casefile}" ]]; then
			# Use du -- to be safe with leading dashes.
			PACKAGE_SIZE=$(( PACKAGE_SIZE + $(du -- "${casefile}" | awk '{print $1}') ))
		fi
	done < <(grep -v '^#' "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" || true)
}
## get_build_time(). Calculates time on build and install a package.
# Usage: get_build_time (without arguments)
# gives: BUILD_TIME variable.
get_build_time()
{
	BUILD_TIME=$((${FINAL_DATE} - ${INITIAL_DATE}))
	BUILD_TIME=$((${BUILD_TIME}/60))
}
## build_nhoid_to_bin(). Create a new nhoid file for binary packages from nhoid for source packages.
# Usage: build_nhoid_to_bin (without arguments)
build_nhoid_to_bin()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
    if [[ -z "${part}" ]]; then
        part=""
    fi
    get_package_display_name "$part"
    
	# Touch new nhoid.
	touch "${NHOPKG_TMPDIR}/nhoid"
	grep '^#%NHO-0.5' "${NHOPKG_TMPDIR}/.nhoid" > "${NHOPKG_TMPDIR}/nhoid"
	grep '^# Package Maintainer:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
	echo >> "${NHOPKG_TMPDIR}/nhoid"
	# Multilib name if it is
	echo -e "# Name:\t${PKG_DISPLAY_NAME}" >> "${NHOPKG_TMPDIR}/nhoid"
	grep '^# Version:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
	grep '^# Release:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
	grep '^# License:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
	# prefix lib32- for lib32 packages with defined groups
	if [ "$part" = "lib32" ] && grep -q '^# Group:' "${NHOPKG_TMPDIR}/.nhoid"; then
		grpval=$(grep '^# Group:' "${NHOPKG_TMPDIR}/.nhoid" | sed 's/^# Group:\t//')
		[ -n "$grpval" ] && echo "# Group:$'\t'lib32-$grpval" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
	else
		grep '^# Group:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
	fi
	# Force "multilib" as repo in lib32 packages
	if [ "$part" = "lib32" ]; then
	echo -e "# Repository:\tmultilib" >> "${NHOPKG_TMPDIR}/nhoid"
	else
	# Copy the Repository field if it exists
	grep '^# Repository:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
	fi
	# Add new arch.
	# Determine architecture correctly based on source package
	original_arch=$(grep "^# Arch:" "${NHOPKG_TMPDIR}/.nhoid" 2>/dev/null | awk -F'\t' '{print $2}' | tr -d '[:space:]')
	if [[ -n "${original_arch}" ]] && ([[ "${original_arch}" == "noarch" ]] || [[ "${original_arch}" == "all" ]] || [[ "${original_arch}" == "any" ]]); then
		final_arch="${original_arch}"
	else
		final_arch="${BUILD_ARCH}"
	fi
	echo -e "# Arch:\t${final_arch}" >> "${NHOPKG_TMPDIR}/nhoid"
	echo -e "# OS:\t${PACKAGE_OS}" >> "${NHOPKG_TMPDIR}/nhoid"
	echo -e "# Installed-Size:\t${PACKAGE_SIZE} KB" >> "${NHOPKG_TMPDIR}/nhoid"
	echo -e "# Build-Duration:\t${BUILD_TIME} min" >> "${NHOPKG_TMPDIR}/nhoid"
	echo -e "# Build-Date:\t${BUILD_DATE}" >> "${NHOPKG_TMPDIR}/nhoid"
	echo -e "# Build-Host:\t${BUILD_HOST}" >> "${NHOPKG_TMPDIR}/nhoid"
	grep '^# Url:' "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
	# Use specific subpackage description if it exists, otherwise use generic + note
	if [[ -n "${part}" ]]; then
    # Try to get a variable like pkgdescription_dev, pkgdescription_docs, etc.
		local specific_desc
		specific_desc=$(eval echo \$"pkgdescription_${part}")
			if [[ -n "${specific_desc}" ]]; then
				echo -e "# Description:\t${specific_desc}" >> "${NHOPKG_TMPDIR}/nhoid"
			else
				echo -e "# Description:\t${pkgdescription} (${part} files.)" >> "${NHOPKG_TMPDIR}/nhoid"
			fi
		else
    # Main package: use base description
			echo -e "# Description:\t${pkgdescription}" >> "${NHOPKG_TMPDIR}/nhoid"
	fi
	# Add new SHA256
	echo -e "# SHA256:\t${PACKAGESHA256}" >> "${NHOPKG_TMPDIR}/nhoid"
	# Add Provides and Conflicts (support split packages)
	if [[ -n "${part}" ]]; then
		# Subpackage: look for Provides_$part and Conflicts_$part
		grep -h "^# Provides_${part}:" "${NHOPKG_TMPDIR}/.nhoid" | sed "s/^# Provides_${part}:/# Provides:/" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
		grep -h "^# Conflicts_${part}:" "${NHOPKG_TMPDIR}/.nhoid" | sed "s/^# Conflicts_${part}:/# Conflicts:/" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
	else
		# Main package: use base Provides and Conflicts
		grep -h "^# Provides:" "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
		grep -h "^# Conflicts:" "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid" 2>/dev/null || true
	fi
    echo >> "${NHOPKG_TMPDIR}/nhoid"
	# Add dependencies.
	# === Add dependencies: one line per Dep(post):, preserving both fields ===
    local dep_pattern="^# Dep${part:+_${part}}(post):"
    local opt_dep_pattern="^# OptionalDep${part:+_${part}}(post):"
    # Process required dependencies: one line per dependency
    grep -h "$dep_pattern" "${NHOPKG_TMPDIR}/.nhoid" | \
        while IFS= read -r line; do
            local dep_data=$(echo "$line" | sed 's/^#[^:]*:\s*//')
            if [[ -n "$dep_data" ]]; then
                echo -e "# Dep(post):\t$dep_data" >> "${NHOPKG_TMPDIR}/nhoid"
            fi
        done
    # Process optional dependencies: one line per dependency
    grep -h "$opt_dep_pattern" "${NHOPKG_TMPDIR}/.nhoid" | \
        while IFS= read -r line; do
            local opt_dep_data=$(echo "$line" | sed 's/^#[^:]*:\s*//')
            if [[ -n "$opt_dep_data" ]]; then
                echo -e "# OptionalDep(post):\t$opt_dep_data" >> "${NHOPKG_TMPDIR}/nhoid"
            fi
        done
    
   	# Add npostinstall() and npostremove() to nhoid.
	echo >> "${NHOPKG_TMPDIR}/nhoid"
	
	# Add npostinstall() or npostinstall_part() to nhoid, with fallback
# Determine names for install and remove
INSTALL_GENERIC="npostinstall"
REMOVE_GENERIC="npostremove"
INSTALL_SPECIFIC="npostinstall${part:+_}${part}"
REMOVE_SPECIFIC="npostremove${part:+_}${part}"

# === npostinstall logic for splitpackages ===
if grep -q "^${INSTALL_SPECIFIC}() {" "${NHOPKG_TMPDIR}/.nhoid"; then
    sed -n "/^${INSTALL_SPECIFIC}() {/,/^}/p" "${NHOPKG_TMPDIR}/.nhoid" | sed  "s|_${part}||g" >> "${NHOPKG_TMPDIR}/nhoid"
    echogn "\t** Using for post-install: " && echo "${INSTALL_SPECIFIC}()"
elif grep -q "^${INSTALL_GENERIC}() {" "${NHOPKG_TMPDIR}/.nhoid"; then
    sed -n "/^${INSTALL_GENERIC}() {/,/^}/p" "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
    echogn "\t** Using as fallback for post-install: " && echo "${INSTALL_GENERIC}()"
else
    echo 'npostinstall() {' >> "${NHOPKG_TMPDIR}/nhoid"
    echo '    noemptyfuncs' >> "${NHOPKG_TMPDIR}/nhoid"
    echo '}' >> "${NHOPKG_TMPDIR}/nhoid"
    echog "Warning: No ${INSTALL_SPECIFIC}() or npostinstall() found. Using placeholder."
fi

# === npostremove logic  for splitpackages ===
if grep -q "^${REMOVE_SPECIFIC}() {" "${NHOPKG_TMPDIR}/.nhoid"; then
    sed -n "/^${REMOVE_SPECIFIC}() {/,/^}/p" "${NHOPKG_TMPDIR}/.nhoid" | sed  "s|_${part}||g" >> "${NHOPKG_TMPDIR}/nhoid"
    echogn "\t** Using for post-remove: " && echo "${REMOVE_SPECIFIC}()"
elif grep -q "^${REMOVE_GENERIC}() {" "${NHOPKG_TMPDIR}/.nhoid"; then
    sed -n "/^${REMOVE_GENERIC}() {/,/^}/p" "${NHOPKG_TMPDIR}/.nhoid" >> "${NHOPKG_TMPDIR}/nhoid"
    echogn "\t** Using as fallback for post-remove: " && echo "${REMOVE_GENERIC}()"
else
    echo 'npostremove() {' >> "${NHOPKG_TMPDIR}/nhoid"
    echo '    noemptyfuncs' >> "${NHOPKG_TMPDIR}/nhoid"
    echo '}' >> "${NHOPKG_TMPDIR}/nhoid"
    echog "Warning: No ${REMOVE_SPECIFIC}() or npostremove() found. Using placeholder."
fi
}
## build_make_binary_package(). Creates binary package from builded package.
# Usage: build_make_binary_package (with/without split arguments)
build_make_binary_package()
{
	local part="$1"  # Parameter for subpackages. If there is no part, we use the main package
	if [[ -z "${part}" ]]; then
		part=""
	fi
	get_package_display_name "$part"

	echog " - Building binary package."
	echog " --- Searching files in the system."
	build_search_for_files ${part}
	## Configure the new binary package
	if [[ -n $(cat "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log") ]]; then
		# Strip binaries and libraries if enabled  (experimental)
		if [[ "${STRIP_BINARIES}" = "yes" ]]; then
			echog " --- Stripping binaries and/or libraries..."

			local processed=0

			while IFS= read -r file; do
				[[ -f "$file" && -r "$file" ]] || continue

				# avoid setuid/setgid
				[[ -u "$file" || -g "$file" ]] && continue

				# ELF check
				[[ $(head -c 4 "$file") != $'\x7fELF' ]] && continue

				local file_output
				file_output=$(file -b "$file" 2>/dev/null)

				# avoid static binaries
				[[ "$file_output" == *"statically linked"* ]] && continue

				if [[ "$file_output" == *"shared object"* ]]; then
					strip --strip-unneeded "$file" 2>/dev/null && ((processed++))
				else
					strip --strip-debug "$file" 2>/dev/null && ((processed++))
				fi
			done < "${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log"

			echog "\t** Stripped $processed ELF files"
		fi
# Package and compress files.
echog " --- Compressing package."
		tar cpP --zstd --files-from="${NHOPKG_TMPDIR}/.${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}-installed.log" > "${NHOPKG_TMPDIR}/data.tar.zst"
		# Sign data.tar.zst if enabled
		if [[ "${NHOPKG_SIGN_PACKAGES}" == "yes" ]] && command -v gpg >/dev/null; then
			echog " --- Signing package with GPG..."
			if ! gpg --default-key "${NHOPKG_SIGN_KEY}" --detach-sign --armor "${NHOPKG_TMPDIR}/data.tar.zst" 2>/dev/null; then
				echog " *** WARNING: Failed to sign package. Continuing without signature." >&2
			else
				mv "${NHOPKG_TMPDIR}/data.tar.zst.asc" "${NHOPKG_TMPDIR}/signature.gpg"
			fi
		fi
		# Go to the temp directory and package.
		cd "${NHOPKG_TMPDIR}"
		# Gets sha256 sum from data.tar.zst
		PACKAGESHA256=$(sha256sum "data.tar.zst")
		# Calcule build and install time.
		get_build_time
		# Touch new nhoid.
		build_nhoid_to_bin ${part}
		# Compress package!
		get_package_display_name "$part"
		OUTPUT_PKG="${CWD}/${PKG_DISPLAY_NAME}-${pkgversion}-${pkgrevision}.${PACKAGE_OS}-${final_arch}.nho"
		tar cp * > "${OUTPUT_PKG}"
		chown "${DIROWNER}" "${OUTPUT_PKG}"
		if [ -f "${OUTPUT_PKG}" ]; then
			echogn " --- New package is:"
			echo " ${OUTPUT_PKG}"
		else
			echog " *** Unable to create binary package." >&2
		fi
	else
		echog " *** Unable to create binary package. Nhopkg can't install any file from this package." >&2
	fi
	# Returns to initial directory.
	cd "${CWD}"
}
#======================================8
# Check (packages) functions.
#======================================8
# empty at the moment.
#======================================10
# List (packages) functions.
#======================================10
## get_list_installed_packages(). Gets installed packages by Nhopkg in the system.
# Usage: get_list_installed_packages (without arguments)
# Gives: installedpackages array.
get_list_installed_packages()
{
	unset installedpackages
	local f
	for f in $(ls "${NHOPKG_LOCALSTATEDIR}/packages/");
	do
		if [[ ! -h "${NHOPKG_LOCALSTATEDIR}/packages/${f}" ]]; then
			if [[ -z "${installedpackages[*]}" ]]; then
				installedpackages=("${f}")
			else
				installedpackages=(${installedpackages[*]} "${f}")
			fi
		fi
	done
}
#======================================11
# Info (packages) functions.
#======================================11
## get_package_info()
# Shows detailed information about a package from any source:
# - Repository (any in NHOPKG_ACTIVE_REPOS)
# - Locally installed package
# - Local .nho file
# Usage: get_package_info "package-name[-version-revision]"
# Returns: 0 if found, 1 if not found
get_package_info()
{
    local pkg_query="$1"
    local found=0
    local repo source_type

    # ============== 1. Buscar en repositorios activos ==============
    if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
        NHOPKG_ACTIVE_REPOS="extra"
    fi

    for repo in ${NHOPKG_ACTIVE_REPOS}; do
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${pkg_query}" ]]; then
            found=1
            source_type="repo"
            break
        fi

        # Soportar búsqueda por nombre base (ej: "zsnes" → "zsnes-1.51-1")
        local candidates=($(find "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/" -maxdepth 1 -name "${pkg_query}-[0-9]*" -type f 2>/dev/null | sort -V | tail -1))
        if [[ ${#candidates[@]} -gt 0 ]]; then
            pkg_query=$(basename "${candidates[0]}")
            found=1
            source_type="repo"
            break
        fi
    done

    # ============== 2. Si no está en repo, buscar instalado localmente ==============
    if [[ $found -eq 0 ]] && [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkg_query}" ]]; then
        found=1
        source_type="installed"
    fi

    # ============== 3. Si no está instalado, verificar si es un .nho local ==============
    if [[ $found -eq 0 ]] && [[ -f "${pkg_query}" ]] && [[ "${pkg_query##*.}" == "nho" ]]; then
        found=1
        source_type="local_nho"
    fi

    # ============== Salir si no se encontró en ningún lado ==============
    if [[ $found -eq 0 ]]; then
        return 1
    fi

    # ============== Extraer y mostrar información ==============
    case "${source_type}" in
        repo)
            # Leer desde repo (ya tenemos pkg_query resuelto)
            local pkg_meta="${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${pkg_query}"
            get_basic_data "${pkg_meta}"

            grep "^# Package Maintainer:" "${pkg_meta}" | sed 's/^# //'
            grep "^# Name:"               "${pkg_meta}" | sed 's/^# //'
            grep "^# Version:"            "${pkg_meta}" | sed 's/^# //'
            grep "^# Release:"            "${pkg_meta}" | sed 's/^# //'

            # ¿Está instalado?
            if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
                echogn "Lasted version installed:"
                echo " ${pkgversion}-${pkgrevision}"
            else
                echog "Lasted version installed: Not installed."
            fi

            grep "^# License:"          "${pkg_meta}" | sed 's/^# //'
            grep "^# Group:"            "${pkg_meta}" | sed 's/^# //'
            grep "^# Arch:"             "${pkg_meta}" | sed 's/^# //'
            grep "^# OS:"               "${pkg_meta}" | sed 's/^# //'
            grep "^# Installed-Size:"   "${pkg_meta}" | sed 's/^# //'
            grep "^# Build-Duration:"   "${pkg_meta}" | sed 's/^# //'
            grep "^# Build-Date:"       "${pkg_meta}" | sed 's/^# //'
            grep "^# Build-Host:"       "${pkg_meta}" | sed 's/^# //'
            grep "^# Url:"              "${pkg_meta}" | sed 's/^# //'
            grep "^# Description:"      "${pkg_meta}" | sed 's/^# //'
            grep "^# Dep(post):"        "${pkg_meta}" | awk -F'\t' '{print "# Dep(post):\t" $2}' | sed 's/^# //'
            grep "^# OptionalDep(post):" "${pkg_meta}" | awk -F'\t' '{print "# OptionalDep(post):\t" $2}' | sed 's/^# //'
            ;;

        installed)
            local pkg_meta="${NHOPKG_LOCALSTATEDIR}/packages/${pkg_query}"
            get_basic_data "${pkg_meta}"

            grep "^# Package Maintainer:" "${pkg_meta}" | sed 's/^# //'
            grep "^# Name:"               "${pkg_meta}" | sed 's/^# //'
            grep "^# Version:"            "${pkg_meta}" | sed 's/^# //'
            grep "^# Release:"            "${pkg_meta}" | sed 's/^# //'

            # ¿Está en algún repo?
            local in_repo=0
            for r in ${NHOPKG_ACTIVE_REPOS}; do
                if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${r}/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
                    echogn "Lasted version available:"
                    echo " ${pkgversion}-${pkgrevision}"
                    in_repo=1
                    break
                fi
            done
            if [[ $in_repo -eq 0 ]]; then
                echog "Lasted version available: Not available."
            fi

            grep "^# License:"          "${pkg_meta}" | sed 's/^# //'
            grep "^# Group:"            "${pkg_meta}" | sed 's/^# //'
            grep "^# Arch:"             "${pkg_meta}" | sed 's/^# //'
            grep "^# OS:"               "${pkg_meta}" | sed 's/^# //'
            grep "^# Installed-Size:"   "${pkg_meta}" | sed 's/^# //'
            grep "^# Build-Duration:"   "${pkg_meta}" | sed 's/^# //'
            grep "^# Build-Date:"       "${pkg_meta}" | sed 's/^# //'
            grep "^# Build-Host:"       "${pkg_meta}" | sed 's/^# //'
            grep "^# Url:"              "${pkg_meta}" | sed 's/^# //'
            grep "^# Description:"      "${pkg_meta}" | sed 's/^# //'
            grep "^# Dep(post):"        "${pkg_meta}" | awk -F'\t' '{print "# Dep(post):\t" $2}' | sed 's/^# //'
            grep "^# OptionalDep(post):" "${pkg_meta}" | awk -F'\t' '{print "# OptionalDep(post):\t" $2}' | sed 's/^# //'
            ;;

        local_nho)
            local nho_file="${pkg_query}"
            # Extraer nhoid temporalmente
            local tmp_nhoid="${NHOPKG_TMPDIR}/nhoid_extracted"
            tar xfO "${nho_file}" nhoid > "${tmp_nhoid}" 2>/dev/null || { return 1; }

            get_basic_data "${tmp_nhoid}"

            grep "^# Package Maintainer:" "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Name:"               "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Version:"            "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Release:"            "${tmp_nhoid}" | sed 's/^# //'

            # Verificar disponibilidad en repos
            local in_repo=0
            for r in ${NHOPKG_ACTIVE_REPOS}; do
                if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${r}/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
                    echogn "Lasted version available:"
                    echo " ${pkgversion}-${pkgrevision}"
                    in_repo=1
                    break
                fi
            done
            if [[ $in_repo -eq 0 ]]; then
                echog "Lasted version available: Not available."
            fi

            # Verificar si está instalado
            if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
                echogn "Lasted version installed:"
                echo " ${pkgversion}-${pkgrevision}"
            else
                echog "Lasted version installed: Not installed."
            fi

            grep "^# License:"          "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Group:"            "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Arch:"             "${tmp_nhoid}" | sed 's/^# //'
            grep "^# OS:"               "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Installed-Size:"   "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Build-Duration:"   "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Build-Date:"       "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Build-Host:"       "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Url:"              "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Description:"      "${tmp_nhoid}" | sed 's/^# //'
            grep "^# Dep(post):"        "${tmp_nhoid}" | awk -F'\t' '{print "# Dep(post):\t" $2}' | sed 's/^# //'
            grep "^# OptionalDep(post):" "${tmp_nhoid}" | awk -F'\t' '{print "# OptionalDep(post):\t" $2}' | sed 's/^# //'

            rm -f "${tmp_nhoid}"
            ;;
    esac

    return 0
}
# ---------------------------------------------------------
# get_repo_url()
# Description: Returns the best available URL for a given repository.
# Parameters: repo_name (e.g., "core", "extra")
# Returns: URL (or exits if none available)
# ---------------------------------------------------------
get_repo_url()
{
    local repo="${1:-extra}"
    local repo_var="NHOPKG_REPO_${repo^^}"  # Convert to uppercase: "core" → "CORE"
    local mirrors="${!repo_var}"

    if [[ -z "${mirrors}" ]]; then
        echog " *** ERROR: No mirrors defined for repository '${repo}'." >&2
        echog "     Please define \$NHOPKG_REPO_${repo^^} in your config." >&2
        exit 1
    fi

    # Convert the mirror string into an array
    read -ra MIRROR_LIST <<< "${mirrors}"

    # Test mirrors in order (optional: add availability check)
    for mirror in "${MIRROR_LIST[@]}"; do
        # Optional: verify that the mirror is live with `wget --spider`
        # But for now, we'll use the first one.
        echo "${mirror}"
        return 0
    done

    echog " *** ERROR: All mirrors failed for repository '${repo}'." >&2
    exit 1
}
#==============================================================================
# Auxiliary functions for upgrade case
#==============================================================================
# ---------------------------------------------------------
# package_exists_in_repos()
# Description: Check if a package exists in the active repositories.
# Parameters: pkg_name
# Returns: 0 if it exists, 1 if it does not exist.
# ---------------------------------------------------------
package_exists_in_repos()
{
    local pkg_name="$1"
    local repo
    
    [[ -z "${NHOPKG_ACTIVE_REPOS}" ]] && NHOPKG_ACTIVE_REPOS="extra"
    
    for repo in ${NHOPKG_ACTIVE_REPOS}; do
        # Check if the exact package exists
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${pkg_name}" ]]; then
            return 0
        fi
        
        # Search for package versions (name-version-revision)
        if find "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/" -maxdepth 1 -name "${pkg_name}-[0-9]*" -type f &>/dev/null; then
            return 0
        fi
    done
    
    return 1
}
# ---------------------------------------------------------
# get_latest_version_in_repos()
# Description: Gets the latest version of a package from the active repositories.
# Parameters: pkg_name
# Returns: Variables pkgname, pkgversion, pkgrevision, pkgrepo.
# ---------------------------------------------------------
get_latest_version_in_repos()
{
    local pkg_name="$1"
    local repo candidate best_version="" best_repo=""
    
    [[ -z "${NHOPKG_ACTIVE_REPOS}" ]] && NHOPKG_ACTIVE_REPOS="extra"
    
    for repo in ${NHOPKG_ACTIVE_REPOS}; do
        # Find the exact version first
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${pkg_name}" ]]; then
            get_basic_data "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/${pkg_name}"
            pkgrepo="${repo}"
            return 0
        fi
        
        # Search for all available versions in this repository
        while IFS= read -r -d '' pkgfile; do
            local pkg_version_file=$(basename "${pkgfile}")
            local pkg_version="${pkg_version_file#${pkg_name}-}"
            
            # Compare versions to find the latest
            if [[ -z "${best_version}" ]] || version_compare "${pkg_version}" ">" "${best_version}"; then
                best_version="${pkg_version}"
                best_repo="${repo}"
                best_pkgfile="${pkgfile}"
            fi
        done < <(find "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages/" -maxdepth 1 -name "${pkg_name}-[0-9]*" -type f -print0 2>/dev/null)
    done
    
    if [[ -n "${best_version}" ]]; then
        get_basic_data "${best_pkgfile}"
        pkgrepo="${best_repo}"
        return 0
    fi
    
    return 1
}
# ---------------------------------------------------------
# update_repositories()
# Description: Updates all configured repositories.
# Parameters: none
# Returns: 0 on success, exits with error on failure.
# ---------------------------------------------------------
update_repositories()
{
    local NHOPKG_OPTION_BACKUP="${NHOPKG_OPTION}"
    NHOPKG_OPTION="update"
    
    get_pwd_dir
    check_if_root_uid
    
    ## 1. Determine active repositories
    if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
        NHOPKG_ACTIVE_REPOS=""
        for var in $(compgen -v NHOPKG_REPO_); do
            repo_name="${var#NHOPKG_REPO_}"
            [[ -n "${!var}" ]] && NHOPKG_ACTIVE_REPOS+="${repo_name} "
        done
        NHOPKG_ACTIVE_REPOS=$(echo "${NHOPKG_ACTIVE_REPOS}" | xargs)
    fi
    
    if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
        echog " * No repositories configured for update." >&2
        NHOPKG_OPTION="${NHOPKG_OPTION_BACKUP}"
        return 1
    fi
    
    ## 2. Synchronize each repository
    for repo in ${NHOPKG_ACTIVE_REPOS}; do
        repo_var="NHOPKG_REPO_${repo^^}"
        repo_url="${!repo_var}"
        if [[ -z "${repo_url}" ]]; then
            echog " *** Skipping '${repo}': no URL defined (\$${repo_var})" >&2
            continue
        fi
        
        echogn " :: Updating repository:"
        echo " ${repo} (${repo_url})"
        
        REPO_PKG_DIR="${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages"
        REPO_FILE_DIR="${NHOPKG_LOCALSTATEDIR}/repo/${repo}/files"
        mkdir -p "${REPO_PKG_DIR}" "${REPO_FILE_DIR}"
        
        # Download lastsync
        wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${repo_url}/lastsync"
        check_if_ok " * Unable to download lastsync for ${repo}."
        
        # Check if it's already updated
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/lastsync" ]]; then
            ISYNC=$(cat "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/lastsync")
            FSYNC=$(cat "${NHOPKG_LOCALSTATEDIR}/cache/lastsync")
            if (( ${ISYNC} >= ${FSYNC} )); then
                echog "   - Already up to date."
                rm -f "${NHOPKG_LOCALSTATEDIR}/cache/lastsync"
                continue
            fi
        fi
        
        # Download databases
        echog "   - Downloading database..."
        wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${repo_url}/core.packages.tar.zst"
        check_if_ok " *** Failed to download packages DB for ${repo}."
        wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${repo_url}/core.files.tar.zst"
        check_if_ok " *** Failed to download files DB for ${repo}."
        
        # Extract files
        zstdcat "${NHOPKG_LOCALSTATEDIR}/cache/core.packages.tar.zst" | tar xfC - "${REPO_PKG_DIR}" 2>/dev/null
        zstdcat "${NHOPKG_LOCALSTATEDIR}/cache/core.files.tar.zst" | tar xfC - "${REPO_FILE_DIR}" 2>/dev/null
        
        # Compress .zst files in /files
        for filedb in "${REPO_FILE_DIR}"/*; do
            if [[ -f "${filedb}" && "${filedb}" != *.zst ]]; then
                zstd --rm "${filedb}" 2>/dev/null
            fi
        done
        
        # Update lastsync
        mv "${NHOPKG_LOCALSTATEDIR}/cache/lastsync" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/lastsync"
        rm -f "${NHOPKG_LOCALSTATEDIR}/cache/core.packages.tar.zst" "${NHOPKG_LOCALSTATEDIR}/cache/core.files.tar.zst"
    done
    
    echog " - All repositories updated successfully."
    NHOPKG_OPTION="${NHOPKG_OPTION_BACKUP}"
    return 0
}
#==============================================================================
# Section: Nhopkg trap.
#==============================================================================
# Check if Nhopkg is running as root.
check_if_running
# If Ctrl+C is pressed, then exits with error.
trap 'cleanup_all; exit 1' INT
trap cleanup_all EXIT TERM
#==============================================================================
# Section: Nhopkg parse options.
#==============================================================================
NHNAME=$(basename "$0")
SHORTOPTIONS="RiSdXrBbklno:wxstg:UehuvCyGA"
LONGOPTIONS="recursive,root:,no-check-deps,no-check-arch,no-check-sha256,force-check-deps,force-check-arch,force-check-sha256,install,super-install,dios,remove,backup,purge,build,check,list,info,output:,show,update-shooters,search,list-repo,create-repo:,update,clean,help,license,license-all,version,update-db,verbose,super-build,sign-package,no-sign-package,verify-package-signature,no-verify-package-signature,upgrade,install-group,strip-binaries,add-to-repo,repo-dir:"
NHPARAMS=$(getopt -o ${SHORTOPTIONS} -l ${LONGOPTIONS} -n ${NHNAME} -- "$@")
if [[ "${?}" != "0" ]]; then
	nhopkg_usage
	exit 1
fi
eval set -- $NHPARAMS
while [[ "${1}" != "--" ]]; do
	case "${1}" in
		-R|--recursive)
			shift
			# Use recursive mode in Nhopkg.
			if [[ "${NHOPKG_RECURSIVE}" != "yes" ]]; then
				NHOPKG_RECURSIVE="yes"
			fi
		;;
		--root)
			shift
			if [[ -d "${1}" ]]; then
				# Delete '/' at the end.
				INSTALL_ROOT=$(echo ${1} | sed -e 's@/$@@')
			else
				echog " * The selected directory doesn't exist in your system." >&2
				exit 1
			fi
			USE_INSTALL_ROOT="yes"
			shift
		;;
		--no-check-deps)
			shift
			# Install package without check dependencies.
			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				NHOPKG_CHECKDEPS="no"
			fi
		;;
		--no-check-arch)
			shift
			# Install package without check arch.
			if [[ "${NHOPKG_CHECKARCH}" = "yes" ]]; then
				NHOPKG_CHECKARCH="no"
			fi
		;;
		--no-check-sha256)
			shift
			# Install package without check arch.
			if [[ "${NHOPKG_CHECKSHA256}" = "yes" ]]; then
				NHOPKG_CHECKSHA256="no"
			fi
		;;
		--force-check-deps)
			shift
			# Force check dependencies.
			if [[ "${NHOPKG_CHECKDEPS}" != "yes" ]]; then
				NHOPKG_CHECKDEPS="yes"
			fi
		;;
		--force-check-arch)
			shift
			# Force check dependencies.
			if [[ "${NHOPKG_CHECKARCH}" != "yes" ]]; then
				NHOPKG_CHECKARCH="yes"
			fi
		;;
		--force-check-sha256)
			shift
			# Force check dependencies.
			if [[ "${NHOPKG_CHECKSHA256}" != "yes" ]]; then
				NHOPKG_CHECKSHA256="yes"
			fi
		;;
		--sign-package)
			shift
			# Sign the binary package when building it.
			if [[ "${NHOPKG_SIGN_PACKAGE}" = "no" ]]; then
				NHOPKG_SIGN_PACKAGE="yes"
			fi
		;;
		--no-sign-package)
			shift
			# Skip the package signature.
			if [[ "${NHOPKG_SIGN_PACKAGE}" = "yes" ]]; then
				NHOPKG_SIGN_PACKAGE="no"
			fi
		;;
		--verify-package-signature)
			shift
			# Verify the GPG signature of the package before installing it.
			if [[ "${NHOPKG_VERIFY_SIGNATURE}" = "no" ]]; then
				NHOPKG_VERIFY_SIGNATURE="yes"
			fi
		;;
		--no-verify-package-signature)
			shift
			# Skip signature verification.
			if [[ "${NHOPKG_VERIFY_SIGNATURE}" = "yes" ]]; then
				NHOPKG_VERIFY_SIGNATURE="no"
			fi
		;;
		-i|--install)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="install"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-d|--dios|-S|--super-install)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="super-install"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-r|--remove)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="remove"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-B|--backup)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="backup"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		--purge)
			shift
			# Purge deprecated packages in system.
			if [[ "${NHOPKG_PURGE}" != "yes" ]]; then
				NHOPKG_PURGE="yes"
			fi
		;;
		-b|--build)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="build"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-C|--super-build)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="super-build"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-k|--check)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="check"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-l|--list)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="list"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-n|--info)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="info"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-o|--output)
			shift
			if [[ -d "${1}" ]]; then
				# Delete '/' at the end.
				OUTPUT_COMMAND=$(echo ${1} | sed -e 's@/$@@')
			else
				echog " * The selected directory doesn't exist in your system." >&2
				exit 1
			fi
			USE_OUTPUT_COMMAND="yes"
			shift
		;;
		-w|--show)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="show"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-x|--update-shooters)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="update-shooters"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-s|--search)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="search"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-t|--list-repo)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="list-repo"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-g|--create-repo)
			shift
			if [[ -d "${1}" ]]; then
				# Delete '/' at the end.
				REPO_DIR="$(echo ${1} | sed -e 's@/$@@')"
			else
				echog " * The selected directory doesn't exist in your system." >&2
				exit 1
			fi
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="create-repo"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
			shift
		;;
		-A|--add-to-repo)
			shift
		if [[ -z "${NHOPKG_OPTION}" ]]; then
			NHOPKG_OPTION="add-to-repo"
		else
			echog " * You have selected more than one valid option." >&2
			exit 1
		fi
		;;
		--repo-dir)
			shift
		if [[ -d "${1}" ]]; then
			REPO_ROOT="$(echo ${1} | sed -e 's@/$@@')"
		else
			echog " * The selected directory doesn't exist in your system." >&2
			exit 1
		fi
			shift
		;;
		-U|--update)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="update"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-e|--clean)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="clean"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-h|--help)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="help"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		--license)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="license"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		--license-all)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="license-all"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		--version)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="version"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-u|--update-db)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="update-db"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-y|--upgrade)
			shift
			if [[ -z "${NHOPKG_OPTION}" ]]; then
				NHOPKG_OPTION="upgrade"
			else
				echog " * You have selected more than one valid option." >&2
				exit 1
			fi
		;;
		-G|--install-group)
			shift
			if [ -z "$NHOPKG_OPTION" ]; then
				NHOPKG_OPTION="install-group"
			else
				echog " * You have selected more than one valid option." >&2
			exit 1
			fi
		;;
		-X|--strip-binaries)
			shift
			if [[ "${STRIP_BINARIES}" != "yes" ]]; then
				STRIP_BINARIES="yes"
			fi
		;;
		-v|--verbose)
			shift
			if [[ "${VERBOSE_MODE}" != "yes" ]]; then
				VERBOSE_MODE="yes"
			fi
		;;
		--)
			shift
			# Stop parssing arguments.
			break
		;;
#		-)
#			# Use stdin as input.
#			break
#		;;
		*)
			shift
		;;
	esac
done
# Get selected packages.
shift
CASEPACKAGES="${@}"
#==============================================================================
# Section: Nhopkg Works!
#==============================================================================
case "${NHOPKG_OPTION}" in
	install)
# ********************************************************************
#
# Section: Install (binary package)
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Checks architecture and SHA256 Sum.
# 4. Checks dependencies.
# 5. Install binary package.
# 6. Configure installation.
# 7. Clean up.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if nhopkg is running as root.
		check_if_root_uid
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			echogn " :: Preparing to install:"
			echo " $(basename ${CASEPACKAGE})"
			check_if_exist_local_package "${CASEPACKAGE}"
			cleanup_tmp_dir
			make_tmp_dir
			# Uncompress package.
			tar xfC "${CASEPACKAGE}" "${NHOPKG_TMPDIR}" 2> /dev/null
			# Comprueba que no ha habido error al descomprimir
			check_if_ok " * Unable to uncompress package."
			# Get data from package.
			# Checks that is good package and get data from it.
			if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
				get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"
				check_package_conflicts "${NHOPKG_TMPDIR}/nhoid"
			else
				echog " * The selected package is not valid." >&2
				# Clean and exits with error.
				cleanup_tmp_dir
				exit 1
			fi
			# Checks if package is aready installed.
			if [[ "${USE_INSTALL_ROOT}" != "yes" ]]; then
				check_if_installed_package
			fi
			## 3. Checks architecture and SHA256 Sum.
			check_package_sha256sum
			check_package_arch
			## 3.5. Verify GPG signature (if enabled)
			verify_package_signature
			# Handle package replacement
			if [[ -n "${REPLACES_PACKAGE}" ]]; then
				remove_replaced_package "${REPLACES_PACKAGE}"
			fi
			## 4. Checks dependencies.
			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				echog " - Resolving Dependencies."
				check_post_dependencies "${NHOPKG_TMPDIR}/nhoid"
				check_optional_post_dependencies "${NHOPKG_TMPDIR}/nhoid"
				askforinstallrequiredeps
				askforinstalloptdeps
			fi
			echog " - Installing package and dependencies."
			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				installrequiredeps
				installoptdeps
			fi
			## 5. Install binary package.
			bin_install
			## 6. Configure installation.
			bin_install_setting_up
			bin_install_create_config_files
			# 7. Clean up.
			cleanup_tmp_dir
			echog " - Installation finished sucessfuly!"
		done
		# Run "shooter_updates" at the end.
        shooter_updates
		# Update DB.
		# If updatedb is here, Nhopkg will be fast.
		update_local_db
		exit 0
	;;
	super-install)
## Options for this command line:
# nhopkg -I | --instrep --> luscus
# nhopkg -R | --repinstall --> pragmart
# nhopkg -R | --requete-install --> pragmart
# nhopkg -F | --free-install --> pragmart
# nhopkg -F | --freebeer-install --> pragmart
# nhopkg -a | --add --> pragmart
# nhopkg -f | --freeadd --> pragmart
# nhopkg -j | --jotahackers-nhopkg-only-adds-free-software --> pragmart
# nhopkg -d | --dios --> pragmart
# ********************************************************************
#
# Section: Super Install (from repos)
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Search packages on repository.
# 4. Checks dependencies.
# 5. Download and install dependencies.
# 6. Checks architecture and SHA256 Sum.
# 7. Install binary package.
# 8. Configure installation.
# 9. Clean up.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if nhopkg is running as root.
		check_if_root_uid
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			echogn " :: Preparing to install:"
			echo " ${CASEPACKAGE}"
			## 3. Search packages on repository.
			# Is possible that package are a package (evident xD) or a file.
			getpackage
			# Checks if package is aready installed.
			if [[ "${USE_INSTALL_ROOT}" != "yes" ]]; then
				check_if_installed_package
			fi
			## 4. Checks dependencies.
			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				echog " - Resolving Dependencies."
				check_post_dependencies "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
				check_optional_post_dependencies "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
				askforinstallrequiredeps
				askforinstalloptdeps
			fi
			## 5. Download and install dependencies.
			# Download package and install it.
			echog " - Installing package and dependencies."
			downloadpackage
			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				installrequiredeps
				installoptdeps
			fi
			# Now install package.
			cleanup_tmp_dir
			make_tmp_dir
			# Uncompress package.
			tar xfC "${NHOPKG_LOCALSTATEDIR}/cache/${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho" "${NHOPKG_TMPDIR}" 2> /dev/null
			check_if_ok " * Unable to uncompress package."
			# Get data from package.
			# Checks that is good package and get data from it.
			if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
				get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"
				check_package_conflicts "${NHOPKG_TMPDIR}/nhoid"
			else
				echog " * The selected package is not valid." >&2
				# Clean and exits with error.
				cleanup_tmp_dir
				exit 1
			fi
			## 6. Checks architecture and SHA256 Sum.
			check_package_sha256sum
			check_package_arch
			## 6.5 Verify GPG signature (if enabled)
			verify_package_signature
			# Handle package replacement
			if [[ -n "${REPLACES_PACKAGE}" ]]; then
				remove_replaced_package "${REPLACES_PACKAGE}"
			fi
			## 7. Install binary package.
			bin_install
			## 8. Configure installation.
			bin_install_setting_up
			bin_install_create_config_files
			# 9. Clean up.
			cleanup_tmp_dir
			echog " - Installation finished sucessfuly!"
		done
		# Run "shooter_updates" at the end.
        shooter_updates
		# If updatedb is here, Nhopkg will be fast.
		update_local_db
		exit 0
	;;
	remove)
# ********************************************************************
#
# Section: Remove (installed packages)
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Check inverse dependencies.
# 4. Ask if continue removing package.
# 5. Remove package and inverse dependencies.
# 6. Clean up .
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if nhopkg is running as root.
		check_if_root_uid
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			echogn " :: Preparing to remove:"
			echo " ${CASEPACKAGE}"
			# Checks that package is installed by Nhopkg.
			if [[ ! -f "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}" ]]; then
				echog " * The selected package is not installed by Nhopkg."
				exit 1
			fi
			# Get data from package.
			get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}"
			## 3. Check inverse dependencies.
			# Check inverse dependencies of package.
			# The first inverse dependency is the same package.
			INVERSEDEPS=("${pkgname}-${pkgversion}-${pkgrevision}")
			if [[ "${NHOPKG_PURGE}" = "yes" ]]; then
				get_list_installed_packages
				check_inverse_dependencies "${pkgname}-${pkgversion}-${pkgrevision}"
			fi
			## 4. Ask if continue removing package.
			if [[ -n "${INVERSEDEPS[1]}" ]]; then
				echogn "The nexts packages will be deleted from your system:"
				IFS=,
				echo " ${INVERSEDEPS[*]}."
				IFS="${OLDIFS}"
			else
				echogn "The next package will be deleted from your system:"
				echo " ${INVERSEDEPS[*]}."
			fi
			nhopkg_ask_follow
			# If NO is select exits.
			check_if_ok " * Package will not be removed from your system."
			## 5. Remove package and inverse dependencies.
			echog " - Removing package and inverse dependencies."
			remove_package_all			
			## 6. Clean up.
			echo -n " - ${pkgname}-${pkgversion}-${pkgrevision} "
			echog "has been removed from your system."
		done
		# Run "shooter_updates" at the end.
        shooter_updates
		# If updatedb is here, Nhopkg will be fast.
		update_local_db
		exit 0
	;;
	backup)
# ********************************************************************
#
# Section: Backup
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Get package files and data.
# 4. Compress new package.
# 5. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if nhopkg is running as root.
		check_if_root_uid
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			echogn " :: Preparing to backup:"
			echo " ${CASEPACKAGE}"
			# Checks that package is installed by Nhopkg.
			if [[ ! -f "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}" ]]; then
				echog " * The selected package is not installed by Nhopkg." >&2
				exit 1
			fi
			# Clean up nhopkg temporal directory.
			cleanup_tmp_dir
			make_tmp_dir
			## 3. Get package files and data.
			# Get data from package.
			get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}"
			grep "^#" "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" > "${NHOPKG_TMPDIR}/nhoid"
			# Create npostinstall function.
			echo >> "${NHOPKG_TMPDIR}/nhoid"
			echo 'npostinstall() {' >> "${NHOPKG_TMPDIR}/nhoid"
			echo 'ldconfig' >> "${NHOPKG_TMPDIR}/nhoid"
			echo '}' >> "${NHOPKG_TMPDIR}/nhoid"
			# Create npostremove function.
			echo >> "${NHOPKG_TMPDIR}/nhoid"
			NPOSTREMOVE_FILE_NUM=$(grep -n "npostremove() {" "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" | sed -e 's@:npostremove() {@@')
			tail -n +${NPOSTREMOVE_FILE_NUM} "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" >> "${NHOPKG_TMPDIR}/nhoid"
			# Compress files in data.tar.zst
			zstd -d "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst"
			# Check that files begin with /.
			if [[ $(grep -m 1 "^/" "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}") ]]; then
				tar --files-from="${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}" -c -p --zstd > "${NHOPKG_TMPDIR}/data.tar.zst" 2> /dev/null
			else
				cd /
				tar --files-from="${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}" -c -p --zstd > "${NHOPKG_TMPDIR}/data.tar.zst" 2> /dev/null
				cd ${PWD}
			fi
			zstd --rm "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}" 2> /dev/null
			## 4. Compress new package.
			# Building binary package.
			cd "${NHOPKG_TMPDIR}"
			# Setting the architecture and os for the nhoid on backup section.
			bakarch="$(grep "# Arch:" ${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision} | sed 's@# Arch:\t@@g')"
			bakos="$(uname -s | awk '{print tolower ($1)}')"
			baksha256="$(sha256sum data.tar.zst)"
			sed -i "s/\(SHA256:\t\).*/SHA256:\t${baksha256}/" nhoid
			tar cp * > "${CWD}/${pkgname}-${pkgversion}-${pkgrevision}.${bakos}-${bakarch}.nho" 2> /dev/null
			chown "${DIROWNER}" "${CWD}/${pkgname}-${pkgversion}-${pkgrevision}.${bakos}-${bakarch}.nho"
			cd ${CWD}
			if [[ -f "${CWD}/${pkgname}-${pkgversion}-${pkgrevision}.${bakos}-${bakarch}.nho" ]]; then
				echogn " --- New package is:"
				echo " ${CWD}/${pkgname}-${pkgversion}-${pkgrevision}.${bakos}-${bakarch}.nho"
			else
				echog " *** Unable to build package." >&2
				cleanup_tmp_dir
				exit 1
			fi
			## 5. Clean up.
			cleanup_tmp_dir
		done
		exit 0
	;;
	build)
# ********************************************************************
#
# Section: Build (source packages)
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Checks architecture and SHA256 Sum.
# 4. Checks dependencies.
# 5. Set build directory and uncompress package.
# 6. Builds package.
# 7. Installs package.
# 8. Builds binary package.
# 9. Clean up and exit.
#
# ********************************************************************

        ## 1. Basic configurations.
        # Sets PWD directory.
        get_pwd_dir
        # Checks if nhopkg is running as root.
        check_if_root_uid
        # Checks if have selected any package.
        if [[ -z "${CASEPACKAGES}" ]]; then
            echog " * Must select package." >&2
            exit 1
        fi

        for CASEPACKAGE in ${CASEPACKAGES}; do
            echogn " :: Preparing to build:"
            echo " $(basename ${CASEPACKAGE})"
            
            # Clean up nhopkg temporal directory.
            cleanup_tmp_dir
            check_if_exist_local_package "${CASEPACKAGE}"
            make_tmp_dir
            
            # Uncompress package.
            tar xfC "${CASEPACKAGE}" "${NHOPKG_TMPDIR}" 2> /dev/null
            check_if_ok " * Unable to uncompress package."
            
            # Get data from package.
            if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
                get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"
                check_package_conflicts "${NHOPKG_TMPDIR}/nhoid"
            else
                echog " * The selected package is not valid." >&2
                cleanup_tmp_dir
                exit 1
            fi

            # Check if package is already installed.
            check_if_installed_package

            ## 3. Checks architecture and SHA256 Sum.
            check_package_sha256sum
            check_package_arch
            # Handle package replacement
			if [[ -n "${REPLACES_PACKAGE}" ]]; then
				remove_replaced_package "${REPLACES_PACKAGE}"
			fi

            ## 4. Checks dependencies.
            if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
                echog " - Resolving Dependencies."
                check_build_dependencies "${NHOPKG_TMPDIR}/nhoid"
                check_optional_build_dependencies "${NHOPKG_TMPDIR}/nhoid"
                check_post_dependencies "${NHOPKG_TMPDIR}/nhoid"
                check_optional_post_dependencies "${NHOPKG_TMPDIR}/nhoid"
                askforinstallrequiredeps
                askforinstalloptdeps
            fi

            echog " - Installing package and dependencies."

            if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
                installrequiredeps
                installoptdeps
            fi

            ## 5. Set build directory and uncompress package.
            build_prepare

            ## 6. Builds package.
            # Set initial date.
            INITIAL_DATE=$(date -u +%s)
            build_package
            check_build_package

            ## 7. Installs package (main one).
            build_package_install  # Sin parámetro → ninstall()

            # Set final date.
            FINAL_DATE=$(date -u +%s)
            check_build_package_install
            # Returns to initial directory.
            cd "${CWD}"

            # Save build and installation logs.
            build_save_log_files

            ## 8. Builds binary package (main one).
            build_make_binary_package

            ## 9. Clean up after main package.
            bin_install_setting_up
            bin_install_create_config_files
        done

        # If SPLITPACKAGE is not empty, create subpackages
        if [[ -n "${SPLITPACKAGE}" ]]; then
            IFS=' ' read -r -a SPLITPARTS <<< "${SPLITPACKAGE}"
            # ensure CASEPACKAGES parsed as array
            IFS=' ' read -r -a CASEPACKAGES_ARRAY <<< "${CASEPACKAGES:-}"
            for part in "${SPLITPARTS[@]}"; do
                for CASEPACKAGE in "${CASEPACKAGES_ARRAY[@]}"; do
                    echogn " :: Preparing split package:"
                    echo " ${part}"

                    # Clean before each split package
                    cleanup_tmp_dir
                    make_tmp_dir

                    # Extract again the source package
                    tar xfC "${CASEPACKAGE}" "${NHOPKG_TMPDIR}" 2> /dev/null
                    check_if_ok " * Unable to uncompress package for split."

                    # Retrieve data from the main package
                    get_basic_data "${NHOPKG_TMPDIR}/nhoid"
                    cp "${NHOPKG_TMPDIR}/nhoid" "${NHOPKG_TMPDIR}/.nhoid"
					
					# Check that the split package is installed
					check_if_installed_package "${part}"
					
					# Generate a temporary nhoid for the split package
					build_nhoid_to_bin "${part}"
					# Now check conflicts using this split-specific metadata
					check_package_conflicts "${NHOPKG_TMPDIR}/nhoid"
					if [[ -n "${REPLACES_PACKAGE}" ]]; then
						remove_replaced_package "${REPLACES_PACKAGE}"
					fi
					# Restore original .nhoid for build steps
					cp "${NHOPKG_TMPDIR}/.nhoid" "${NHOPKG_TMPDIR}/nhoid"
					get_basic_data "${NHOPKG_TMPDIR}/nhoid"
					
                    # Set build directory and uncompress package again.
                    build_prepare

                    # Builds package for this part
                    build_package "${part}"

                    # Installs package for this part
                    build_package_install "${part}"

                    # Search files for this part
                    build_search_for_files "${part}"

                    # Create the binary package for this part
                    build_make_binary_package "${part}"

                    # Configure post-installation
                    bin_install_setting_up "${part}"
                    bin_install_create_config_files "${part}"

                    # Save log files for this part
                    build_save_log_files "${part}"

                    # Clean up after each part
                    cleanup_tmp_dir
                    cleanup_build_dir
                done
            done
        fi
        # Run "shooter_updates" at the end.
        shooter_updates
		# Final clean up
        update_local_db
        echog " - Source installation finished successfully!"
        exit 0
    ;;
	super-build)
# ********************************************************************
#
# Section: Super Build (source from Git repository)
# 1. Basic configurations.
# 2. Clone Git repository using NHOPKG_GIT_SOURCES and package name.
# 3. Read nhoid to extract version and release.
# 4. Reconstruct CASEPACKAGE as pkgname-pkgversion-pkgrevision.
# 5. Prepare build environment like a .srcnho package (nhoid, others/, patches/).
# 6. Checks architecture and SHA256 Sum (if applicable).
# 7. Checks and installs build and runtime dependencies.
# 8. Builds, installs, and creates binary package(s) (including split packages).
# 9. Clean up and exit.
#
# ********************************************************************
		get_pwd_dir
		check_if_root_uid
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select a package name." >&2
			exit 1
		fi

		# We keep the original names (only names, no version)
		ORIGINAL_CASEPACKAGES="${CASEPACKAGES}"

		for CASEPACKAGE in ${ORIGINAL_CASEPACKAGES}; do
			pkgname="${CASEPACKAGE}"
			echogn " :: Preparing to super-build:"
			echo " ${pkgname}"

			cleanup_tmp_dir
			make_tmp_dir

			# 1. Set repo URL
			git_url="${NHOPKG_GIT_SOURCES}/${pkgname}.git"

			# 2. Clone repo to temporary directory
			build_clone_dir="${NHOPKG_TMPDIR}/.gitclone"
			echog " - Cloning ${git_url}..."
			git clone --depth=1 "${git_url}" "${build_clone_dir}" 2>/dev/null || {
				echog " * Failed to clone ${git_url}" >&2
				cleanup_tmp_dir
				exit 1
			}

			# 3. Verify that nhoid file exists
			if [[ ! -f "${build_clone_dir}/nhoid" ]]; then
				echog " * nhoid not found in repository!" >&2
				cleanup_tmp_dir
				exit 1
			fi

			# 4. Imitate decompression of .srcnho
			mv "${build_clone_dir}/nhoid" "${NHOPKG_TMPDIR}/"

			if [[ -d "${build_clone_dir}/others" ]]; then
				cp -r "${build_clone_dir}/others"/* "${NHOPKG_TMPDIR}/" 2>/dev/null || true
			fi

			if [[ -d "${build_clone_dir}/patches" ]]; then
				cp -r "${build_clone_dir}/patches"/* "${NHOPKG_TMPDIR}/" 2>/dev/null || true
			fi

			rm -rf "${build_clone_dir}"

			# 5. Load real data from the nhoid
			if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
				get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"
				# Save original name for later use in split packages
				ORIGINAL_PKGNAME="${pkgname}"
				check_package_conflicts "${NHOPKG_TMPDIR}/nhoid"
			else
				echog " * Invalid source package." >&2
				cleanup_tmp_dir
				exit 1
			fi

			# Redefine CASEPACKAGE with full format
			CASEPACKAGE="${pkgname}-${pkgversion}-${pkgrevision}"
			# We also updated CASEPACKAGES so that subpackages can use it
			CASEPACKAGES="${CASEPACKAGE}"
			
			# Check if package is already installed.
			check_if_installed_package
			
			## 3. Checks architecture and SHA256 Sum.
			check_package_sha256sum
			check_package_arch
			# Handle package replacement
			if [[ -n "${REPLACES_PACKAGE}" ]]; then
				remove_replaced_package "${REPLACES_PACKAGE}"
			fi
			
			## 4. Checks dependencies.
			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				echog " - Resolving Dependencies."
				check_build_dependencies "${NHOPKG_TMPDIR}/nhoid"
				check_optional_build_dependencies "${NHOPKG_TMPDIR}/nhoid"
				check_post_dependencies "${NHOPKG_TMPDIR}/nhoid"
				check_optional_post_dependencies "${NHOPKG_TMPDIR}/nhoid"
				askforinstallrequiredeps
				askforinstalloptdeps
			fi

			if [[ "${NHOPKG_CHECKDEPS}" = "yes" ]]; then
				installrequiredeps
				installoptdeps
			fi
			
			## 5. Set build directory and uncompress package.
            build_prepare

            ## 6. Builds package.
            # Set initial date.
			INITIAL_DATE=$(date -u +%s)
			build_package
			check_build_package
			
			## 7. Installs package (main one).
            build_package_install  # Sin parámetro → ninstall()
            
			# Set final date.
            FINAL_DATE=$(date -u +%s)
            check_build_package_install
            # Returns to initial directory.
            cd "${CWD}"
            
			# Save build and installation logs.
            build_save_log_files

            ## 8. Builds binary package (main one).
            build_make_binary_package

            ## 9. Clean up after main package.
            bin_install_setting_up
            bin_install_create_config_files
		done

		# Support for subpackages (same as --build)
		if [[ -n "${SPLITPACKAGE}" ]]; then
			IFS=' ' read -r -a SPLITPARTS <<< "${SPLITPACKAGE}"
            # ensure CASEPACKAGES parsed as array
            IFS=' ' read -r -a CASEPACKAGES_ARRAY <<< "${CASEPACKAGES:-}"
            for part in "${SPLITPARTS[@]}"; do
                for CASEPACKAGE in "${CASEPACKAGES_ARRAY[@]}"; do
					echogn " :: Preparing split package:"
					echo " ${part}"
					
					# Clean before each split package
					cleanup_tmp_dir
					make_tmp_dir

					# Here CASEPACKAGE is already "version-name-revision"
					# We extract only the base name for the URL
					pkg_base_name="${ORIGINAL_PKGNAME}"
					git_url="${NHOPKG_GIT_SOURCES}/${pkg_base_name}.git"

					build_clone_dir="${NHOPKG_TMPDIR}/.gitclone"
					git clone --depth=1 "${git_url}" "${build_clone_dir}" 2>/dev/null || {
						echog " * Failed to clone ${git_url}" >&2
						cleanup_tmp_dir
						exit 1
					}

					if [[ ! -f "${build_clone_dir}/nhoid" ]]; then
						echog " * nhoid not found in repository!" >&2
						cleanup_tmp_dir
						exit 1
					fi

					mv "${build_clone_dir}/nhoid" "${NHOPKG_TMPDIR}/"
					if [[ -d "${build_clone_dir}/others" ]]; then
						cp -r "${build_clone_dir}/others"/* "${NHOPKG_TMPDIR}/" 2>/dev/null || true
					fi
					if [[ -d "${build_clone_dir}/patches" ]]; then
						cp -r "${build_clone_dir}/patches"/* "${NHOPKG_TMPDIR}/" 2>/dev/null || true
					fi
					rm -rf "${build_clone_dir}"

					# Retrieve data from the main package
                    get_basic_data "${NHOPKG_TMPDIR}/nhoid"
                    cp "${NHOPKG_TMPDIR}/nhoid" "${NHOPKG_TMPDIR}/.nhoid"
					
					# Check that the split package is installed
					check_if_installed_package "${part}"
					
					# Generate a temporary nhoid for the split package
					build_nhoid_to_bin "${part}"
					# Now check conflicts using this split-specific metadata
					check_package_conflicts "${NHOPKG_TMPDIR}/nhoid"
					if [[ -n "${REPLACES_PACKAGE}" ]]; then
						remove_replaced_package "${REPLACES_PACKAGE}"
					fi
					# Restore original .nhoid for build steps
					cp "${NHOPKG_TMPDIR}/.nhoid" "${NHOPKG_TMPDIR}/nhoid"
					get_basic_data "${NHOPKG_TMPDIR}/nhoid"
					
					# Set build directory and uncompress package again.
                    build_prepare
					
					# Builds package for this part
                    build_package "${part}"

                    # Installs package for this part
                    build_package_install "${part}"

                    # Search files for this part
                    build_search_for_files "${part}"
					
					# Create the binary package for this part
                    build_make_binary_package "${part}"

                    # Configure post-installation
                    bin_install_setting_up "${part}"
                    bin_install_create_config_files "${part}"
                    
                    # Save log files for this part
					build_save_log_files "${part}"
					
					# Clean up after each part
					cleanup_tmp_dir
				done
			done
		fi

		shooter_updates
		update_local_db
		echog " - Git Source instalation finished successfully!"
		exit 0
	;;
	check)
# ********************************************************************
#
# Section: Check
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Shows package info and files.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if have selected any package.
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			if [[ ! -f "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}" ]]; then
				echog " * The selected package is not installed by Nhopkg." >&2
				continue
			fi
			get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}"
			echogn " :: Checking for:"
			echo " ${pkgname}-${pkgversion}-${pkgrevision}"
			# Set the 100% percent.
			LISTED_FILES_NUM=$(zstdgrep -vc '^#' "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst" 2> /dev/null)
			CHECKED_FILES_NUM=0
			for checked_file in $(zstdgrep -v '^#' "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst" 2> /dev/null);
			do
				if [[ -e "${checked_file}" ]]; then
					((CHECKED_FILES_NUM++))
				fi
			done
			PERCENT=$((${CHECKED_FILES_NUM} * 100 / ${LISTED_FILES_NUM}))
			if [[ "${CHECKED_FILES_NUM}" != "${LISTED_FILES_NUM}" ]]; then
				echog " *** Package check fail!"
				echo -n "${CHECKED_FILES_NUM} "
				echogn "of"
				echo -n " ${LISTED_FILES_NUM} "
				echogn "files are present."
				echo " (${PERCENT}%)"
			else
				echog " --- Package check ok!"
				echo -n "${CHECKED_FILES_NUM} "
				echogn "of"
				echo -n " ${LISTED_FILES_NUM} "
				echogn "files are present."
				echo " (${PERCENT}%)"
			fi
		done
		exit 0
	;;
	create-repo)
    # ********************************************************************
    #
    # Section: Create Repo (Multiple Repositories)
    # 1. Basic configurations.
    # 2. Check input directory (source of .nho files).
    # 3. Determine active repositories from config (NHOPKG_ACTIVE_REPOS).
    # 4. Iterate through .nho files in input directory.
    # 5. Extract # Repository: from nhoid inside each .nho.
    # 6. Assign to 'extra' if # Repository: is missing or invalid.
    # 7. Group .nho files by determined repository.
    # 8. For each active repo with assigned packages:
    #    a. Create temporary staging area for that repo's metadata.
    #    b. Process assigned .nho files, adding their metadata to staging.
    #    c. Create repo-specific packages.tar.zst and files.tar.zst.
    #    d. Place final files in subdirectory within output directory (e.g., REPO_DIR/core/, REPO_DIR/extra/).
    #    e. Copy original .nho files to the corresponding repo subdirectory.
    # 9. Clean up and exit.
    #
    # ********************************************************************

    # 1. Basic configurations.
    echogn " :: Creating software repository from:"
    echo " ${REPO_DIR}" # This is the INPUT directory containing .nho files
    # Define OUTPUT directory (could be the same as input or different)
    # For this example, assume REPO_DIR is the output root where subdirectories (core/, extra/, etc.) will be created.
    REPO_OUTPUT_ROOT="${REPO_DIR}"
    get_pwd_dir
    check_if_root_uid

    # 2. Check input directory.
    if [[ ! -d "${REPO_OUTPUT_ROOT}" ]]; then
        echog " * Input/output directory does not exist: ${REPO_OUTPUT_ROOT}" >&2
        exit 1
    fi

    # 3. Determine active repositories from config.
    if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
        # Auto-detect like in 'update' section if not explicitly set
        NHOPKG_ACTIVE_REPOS=""
        for var in $(compgen -v NHOPKG_REPO_); do
            repo_name="${var#NHOPKG_REPO_}"
            # Only add if NHOPKG_REPO_<name> is defined and not empty
            if [[ -n "${!var}" ]]; then
                NHOPKG_ACTIVE_REPOS+="${repo_name} "
            fi
        done
        NHOPKG_ACTIVE_REPOS=$(echo "${NHOPKG_ACTIVE_REPOS}" | xargs) # Trim whitespace
    fi

    if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
        echog " * No active repositories configured (NHOPKG_ACTIVE_REPOS is empty)." >&2
        exit 1
    fi
    echogn " :: Active Repositories:"
    for repo_name in ${NHOPKG_ACTIVE_REPOS}; do
        echo " - ${repo_name}"
    done

    # 4. Clean up nhopkg temporal directory.
    cleanup_tmp_dir
    make_tmp_dir

    # Find all .nho packages in the input directory
    nhopackage_list=()
    while IFS= read -r -d '' nhopackage_file; do
        nhopackage_list+=("$nhopackage_file")
    done < <(find "${REPO_OUTPUT_ROOT}" -maxdepth 1 -name '*.nho' -print0)

    if (( ${#nhopackage_list[@]} == 0 )); then
        echog " *** No .nho packages found in input directory: ${REPO_OUTPUT_ROOT}" >&2
        cleanup_tmp_dir
        exit 1
    fi

    # 5, 6, 7. Determine repo for each .nho and group them.
    declare -A repo_packages # Associative array: repo_name -> list of .nho paths
    for nhopackage_path in "${nhopackage_list[@]}"; do
        nhopackage_basename=$(basename "${nhopackage_path}")

        # Extract # Repository: field from the nhoid inside the .nho package
        pkg_repo=$(tar xfO "${nhopackage_path}" "nhoid" 2>/dev/null | grep "^# Repository:" | awk -F'\t' '{print $2}' | tr '[:upper:]' '[:lower:]')

        if [[ -z "${pkg_repo}" ]]; then
            echog " - Package ${nhopackage_basename} has no '# Repository:' field. Assigning to 'extra'."
            pkg_repo="extra"
        else
            # Validate against active repos
            repo_found=0
            for active_repo in ${NHOPKG_ACTIVE_REPOS}; do
                if [[ "${pkg_repo}" == "${active_repo}" ]]; then
                    repo_found=1
                    break
                fi
            done
            if [[ ${repo_found} -eq 0 ]]; then
                echog " - Package ${nhopackage_basename} assigned to repository '${pkg_repo}', which is not in NHOPKG_ACTIVE_REPOS. Assigning to 'extra' instead."
                pkg_repo="extra"
            fi
        fi

        # Add to the appropriate list
        repo_packages["${pkg_repo}"]+="${nhopackage_path} "
        echogn " - Package ${nhopackage_basename}"
        echo "   -> Repository: ${pkg_repo}"
    done

    # 8. Process each active repository that has packages assigned.
    for repo_name in ${NHOPKG_ACTIVE_REPOS}; do
        repo_pkg_list_str="${repo_packages[${repo_name}]}"
        if [[ -z "${repo_pkg_list_str}" ]]; then
            echog " :: No packages found for repository: ${repo_name}. Skipping metadata generation and copy."
            continue
        fi

        echogn " :: Processing repository: ${repo_name}"
        repo_pkg_list=($repo_pkg_list_str) # Convert string list to array

        # --- Create target directory for .nho files for this repo ---
        repo_nho_dir="${REPO_OUTPUT_ROOT}/${repo_name}"
        mkdir -p "${repo_nho_dir}"

        # --- Staging area for this specific repo's metadata ---
        repo_tmp_dir="${NHOPKG_TMPDIR}/${repo_name}_staging"
        mkdir -p "${repo_tmp_dir}"
        repo_packages_file="${repo_tmp_dir}/repo_packages.tar"
        repo_files_file="${repo_tmp_dir}/repo_files.tar"

        # Ensure tar files start fresh
        tar cf "${repo_packages_file}" --files-from /dev/null 2>/dev/null || touch "${repo_packages_file}"
        tar cf "${repo_files_file}" --files-from /dev/null 2>/dev/null || touch "${repo_files_file}"

        # --- Process each .nho assigned to this repo ---
        for nhopackage_path in "${repo_pkg_list[@]}"; do
            nhopackage_basename=$(basename "${nhopackage_path}")
            echogn " - Adding"
            echo " ${nhopackage_basename}..."

            # Extract nhoid to get metadata
            if ! tar xfO "${nhopackage_path}" "nhoid" 2> /dev/null > "${NHOPKG_TMPDIR}/nhoid"; then
                 echog " * Error: Failed to extract 'nhoid' from ${nhopackage_path}" >&2
                 cleanup_tmp_dir
                 exit 1
            fi

            # Load metadata from the extracted nhoid
            if [[ -f "${NHOPKG_TMPDIR}/nhoid" ]]; then
                # Ensure we get the correct pkgname, pkgversion, pkgrevision
                # Use the get_basic_data function or similar logic to populate them
                get_nhoid_data "${NHOPKG_TMPDIR}/nhoid" # This populates pkgname, pkgversion, pkgrevision, etc.
            else
                 echog " * Error: Extracted 'nhoid' from ${nhopackage_path} is invalid." >&2
                 cleanup_tmp_dir
                 exit 1
            fi

            # --- Add package metadata entry to repo_packages_file ---
            # Create a temporary file with the correct name structure
            pkg_metadata_name="${pkgname}-${pkgversion}-${pkgrevision}"
            mv "${NHOPKG_TMPDIR}/nhoid" "${repo_tmp_dir}/${pkg_metadata_name}"
            # Create symlinks for name and name-version
            ln -sf "${pkg_metadata_name}" "${repo_tmp_dir}/${pkgname}-${pkgversion}"
            ln -sf "${pkg_metadata_name}" "${repo_tmp_dir}/${pkgname}"

            # Add the metadata files (pkgname-ver-rev, symlinks) to the packages tar
            tar rf "${repo_packages_file}" -C "${repo_tmp_dir}" "${pkg_metadata_name}" "${pkgname}-${pkgversion}" "${pkgname}"

            # --- Add file list entry to repo_files_file ---
            # Extract the file list from the .nho package (assuming it's stored as 'files' inside)
            # You might need to adapt this if the file list is stored differently
            # For now, let's assume it exists as 'files' inside the .nho
            # Create a temporary file named after the package to hold its file list
            pkg_files_name="${pkgname}-${pkgversion}-${pkgrevision}"
            if tar -xf "${nhopackage_path}" --to-command='zstd -dc | tar -tf -' data.tar.zst > "${repo_tmp_dir}/${pkg_files_name}" 2>/dev/null; then
            #if tar xfO "${nhopackage_path}" "files" 2>/dev/null > "${repo_tmp_dir}/${pkg_files_name}"; then
                 # Add the file list file to the files tar
                 tar rf "${repo_files_file}" -C "${repo_tmp_dir}" "${pkg_files_name}"
                 # Compress the individual file list file
                 zstd --rm "${repo_tmp_dir}/${pkg_files_name}" 2>/dev/null
            else
                 echog " - Warning: No 'files' list found in ${nhopackage_basename}. Skipping file list entry."
                 # Create an empty file list entry anyway to maintain structure?
                 # touch "${repo_tmp_dir}/${pkg_files_name}"
                 # tar rf "${repo_files_file}" -C "${repo_tmp_dir}" "${pkg_files_name}"
                 # zstd --rm "${repo_tmp_dir}/${pkg_files_name}" 2>/dev/null
            fi

            # Clean up temporary nhoid file for next iteration
            rm -f "${repo_tmp_dir}/${pkg_metadata_name}" "${repo_tmp_dir}/${pkgname}" "${repo_tmp_dir}/${pkgname}-${pkgversion}"

            # --- Copy .nho file to corresponding repo subdirectory ---
            # Determine destination path for the .nho file
            dest_nho_path="${repo_nho_dir}/${nhopackage_basename}"
            # Only copy if it's not already in the target directory (to avoid overwriting or unnecessary copy if input=output)
            if [[ "${nhopackage_path}" != "${dest_nho_path}" ]]; then
                echogn "   - Copying .nho file to ${repo_name}/ directory..."
                # Use cp to copy, preserving attributes might be useful (-p), but -a is often too much (preserves links/ownership)
                # Standard cp should suffice for the file itself
                if ! cp "${nhopackage_path}" "${dest_nho_path}"; then
                     echog "   * Error: Failed to copy ${nhopackage_basename} to ${repo_nho_dir}/" >&2
                     # Decide whether to exit or continue processing other packages for this repo
                     # For now, let's continue
                     continue
                fi
                echog "   - Copied ${nhopackage_basename} to ${repo_nho_dir}/"
            else
                # If the input path is the same as the output path (e.g., REPO_DIR is both input and output root),
                # the .nho is already in the right place conceptually. We could log this.
                echog "   - .nho file ${nhopackage_basename} is already in the target directory ${repo_nho_dir}/"
            fi
            # --- End of copy section ---

        done # End loop for packages in this repo

        # --- Compress and finalize metadata for this repo ---
        # repo_final_dir is already set to "${REPO_OUTPUT_ROOT}/${repo_name}" where .nho files were copied
        # repo_final_dir="${REPO_OUTPUT_ROOT}/${repo_name}" # This is implied from repo_nho_dir

        # Compress the accumulated tar files for this repo
        if [[ -f "${repo_packages_file}" ]] && [[ -s "${repo_packages_file}" ]]; then
            zstd --rm "${repo_packages_file}" 2> /dev/null
            if [[ $? -ne 0 ]]; then
                 echog " *** Unable to compress packages DB for ${repo_name}." >&2
                 cleanup_tmp_dir
                 exit 1
            fi
            mv "${repo_packages_file}.zst" "${repo_nho_dir}/core.packages.tar.zst" # Keep 'core' name for compatibility with 'update' logic if needed, or use ${repo_name}.packages.tar.zst
            # If using ${repo_name}.packages.tar.zst, 'update' section needs adjustment
        else
             echog " - No packages added for ${repo_name}, not creating packages DB."
        fi

        if [[ -f "${repo_files_file}" ]] && [[ -s "${repo_files_file}" ]]; then
            zstd --rm "${repo_files_file}" 2> /dev/null
            if [[ $? -ne 0 ]]; then
                 echog " *** Unable to compress files DB for ${repo_name}." >&2
                 cleanup_tmp_dir
                 exit 1
            fi
            mv "${repo_files_file}.zst" "${repo_nho_dir}/core.files.tar.zst" # Keep 'core' name for compatibility with 'update' logic if needed, or use ${repo_name}.files.tar.zst
            # If using ${repo_name}.files.tar.zst, 'update' section needs adjustment
        else
             echog " - No files added for ${repo_name}, not creating files DB."
        fi

        # Update lastsync for this repo
        echo $(date -u +%s) > "${repo_nho_dir}/lastsync"
        
        # Create content.db for this repo
        cd "${repo_nho_dir}" && du *[0-9].nho > content.db && zstd --rm content.db && cd "${CWD}"
        echog " - Repository '${repo_name}' metadata created and .nho files copied successfully in ${repo_nho_dir}."

    done # End loop for active repos

    echog " - All repository metadata has been created and .nho files copied successfully."

    # 9. Clean up and exit.
    cleanup_tmp_dir
    exit 0
    ;;
            
	update)
# ********************************************************************
#
# Section: Update (Multiple Repositories)
# 1. Basic configurations.
# 2. Determine active repositories from config.
# 3. Sync each repository to its subdirectory.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		get_pwd_dir
		check_if_root_uid

		# If multiple repositories were not defined, use the old behavior
		if [[ -z "${NHOPKG_REPO_EXTRA}" && -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
			echogn " :: Updating from single repository:"
			echo " ${NHOPKG_REPO}"
			NHOPKG_REPO=$(echo "${NHOPKG_REPO}" | sed -e 's@/$@@')
			# --- Original behavior here (code unchanged) ---
			if [[ ! -d "${NHOPKG_LOCALSTATEDIR}/repo" ]]; then
				mkdir -p "${NHOPKG_LOCALSTATEDIR}/repo/packages"
				mkdir -p "${NHOPKG_LOCALSTATEDIR}/repo/files"
			elif [[ ! -d "${NHOPKG_LOCALSTATEDIR}/repo/packages" ]]; then
				mkdir -p "${NHOPKG_LOCALSTATEDIR}/repo/packages"
			elif [[ ! -d "${NHOPKG_LOCALSTATEDIR}/repo/files" ]]; then
				mkdir -p "${NHOPKG_LOCALSTATEDIR}/repo/files"
			elif [[ ! -d "${NHOPKG_LOCALSTATEDIR}/cache" ]]; then
				mkdir -p "${NHOPKG_LOCALSTATEDIR}/cache"
			fi
			if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/lastsync" ]]; then
				wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${NHOPKG_REPO}/lastsync"
				check_if_ok " * Unable to download files from repository."
				ISYNC=$(cat ${NHOPKG_LOCALSTATEDIR}/repo/lastsync)
				FSYNC=$(cat ${NHOPKG_LOCALSTATEDIR}/cache/lastsync)
				if (( ${ISYNC} == ${FSYNC} )) || (( ${ISYNC} > ${FSYNC} )); then
					echog " * Repository already is updated." >&2
					exit 1
				fi
				rm -f "${NHOPKG_LOCALSTATEDIR}/repo/lastsync"
			else
				wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${NHOPKG_REPO}/lastsync"
				check_if_ok " * Unable to download files from repository."
				rm -f "${NHOPKG_LOCALSTATEDIR}/repo/files/"*
				rm -f "${NHOPKG_LOCALSTATEDIR}/repo/packages/"*
			fi
			echog " - Downloading configuration files from server."
			wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${NHOPKG_REPO}/content.db.zst"
			check_if_ok " * Unable to download files from repository."
			echog " --- Downloading files database."
			wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${NHOPKG_REPO}/core.files.tar.zst"
			check_if_ok " *** Unable to download files from repository."
			echog " --- Downloading packages database."
			wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${NHOPKG_REPO}/core.packages.tar.zst"
			check_if_ok " *** Unable to download files from repository."
			mv "${NHOPKG_LOCALSTATEDIR}/cache/content.db.zst" "${NHOPKG_LOCALSTATEDIR}/repo/content.db.zst"
			zstdcat "${NHOPKG_LOCALSTATEDIR}/cache/core.packages.tar.zst" | tar xfC - "${NHOPKG_LOCALSTATEDIR}/repo/packages" 2> /dev/null
			zstdcat "${NHOPKG_LOCALSTATEDIR}/cache/core.files.tar.zst" | tar xfC - "${NHOPKG_LOCALSTATEDIR}/repo/files" 2> /dev/null
			for i in $(ls "${NHOPKG_LOCALSTATEDIR}/repo/files" 2>/dev/null); do
				zstd --rm "${NHOPKG_LOCALSTATEDIR}/repo/files/${i}" 2> /dev/null
			done
			mv "${NHOPKG_LOCALSTATEDIR}/cache/lastsync" "${NHOPKG_LOCALSTATEDIR}/repo/lastsync"
			echog " - Repository database updated successfully."
			rm -rf "${NHOPKG_LOCALSTATEDIR}/cache/core.packages.tar.zst"
			rm -rf "${NHOPKG_LOCALSTATEDIR}/cache/core.files.tar.zst"
			exit 0
		fi

		## 2. Determine active repositories
		# If NHOPKG_ACTIVE_REPOS was not defined, use all those that have NHOPKG_REPO_*
		if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
			# Auto-detect repositories from variables NHOPKG_REPO_*
			NHOPKG_ACTIVE_REPOS=""
			for var in $(compgen -v NHOPKG_REPO_); do
				repo_name="${var#NHOPKG_REPO_}"
				NHOPKG_ACTIVE_REPOS+="${repo_name} "
			done
			NHOPKG_ACTIVE_REPOS=$(echo "${NHOPKG_ACTIVE_REPOS}" | xargs)
		fi

		if [[ -z "${NHOPKG_ACTIVE_REPOS}" ]]; then
			echog " * No repositories configured for update." >&2
			exit 1
		fi

		## 3. Sync each repository
		for repo in ${NHOPKG_ACTIVE_REPOS}; do
			# Get repository URL
			repo_var="NHOPKG_REPO_${repo^^}"
			repo_url="${!repo_var}"
			if [[ -z "${repo_url}" ]]; then
				echog " *** Skipping '${repo}': no URL defined (\$NHOPKG_REPO_${repo^^})" >&2
				continue
			fi

			echogn " :: Updating repository:"
			echo " ${repo} (${repo_url})"

			# Specific directories
			REPO_PKG_DIR="${NHOPKG_LOCALSTATEDIR}/repo/${repo}/packages"
			REPO_FILE_DIR="${NHOPKG_LOCALSTATEDIR}/repo/${repo}/files"
			mkdir -p "${REPO_PKG_DIR}" "${REPO_FILE_DIR}"

			# Download lastsync
			wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${repo_url}/lastsync"
			check_if_ok " * Unable to download lastsync for ${repo}."

			# Check if it's already synchronized
			if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/lastsync" ]]; then
				ISYNC=$(cat "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/lastsync")
				FSYNC=$(cat "${NHOPKG_LOCALSTATEDIR}/cache/lastsync")
				if (( ${ISYNC} >= ${FSYNC} )); then
					echog "   - Already up to date."
					rm -f "${NHOPKG_LOCALSTATEDIR}/cache/lastsync"
					continue
				fi
			fi

			# Download databases
			echog "   - Downloading database..."
			wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${repo_url}/core.packages.tar.zst"
			check_if_ok " *** Failed to download packages DB for ${repo}."
			wget --https-only -cqt 3 --directory-prefix="${NHOPKG_LOCALSTATEDIR}/cache" "${repo_url}/core.files.tar.zst"
			check_if_ok " *** Failed to download files DB for ${repo}."

			# Extract to the repo subdirectory
			zstdcat "${NHOPKG_LOCALSTATEDIR}/cache/core.packages.tar.zst" | tar xfC - "${REPO_PKG_DIR}" 2>/dev/null
			zstdcat "${NHOPKG_LOCALSTATEDIR}/cache/core.files.tar.zst" | tar xfC - "${REPO_FILE_DIR}" 2>/dev/null

			# Compress .zst files in /files (like the original does)
			for filedb in "${REPO_FILE_DIR}"/*; do
				if [[ -f "${filedb}" && "${filedb}" != *.zst ]]; then
					zstd --rm "${filedb}" 2>/dev/null
				fi
			done

			# Move lastsync
			mv "${NHOPKG_LOCALSTATEDIR}/cache/lastsync" "${NHOPKG_LOCALSTATEDIR}/repo/${repo}/lastsync"

			# Cleaning temporary repo cache
			rm -f "${NHOPKG_LOCALSTATEDIR}/cache/core.packages.tar.zst" "${NHOPKG_LOCALSTATEDIR}/cache/core.files.tar.zst"
		done

		echog " - All repositories updated successfully."
		exit 0
	;;
	add-to-repo)
	# ==========================================================
	# Section: Incremental Repository Update (Safe Mode)
	# ----------------------------------------------------------
	# Adds .nho packages to repository root
	# Keeps ONLY latest version per package
	# Rebuilds:
	#       core.packages.tar.zst
	#       core.files.tar.zst
	#       content.db.zst
	#       lastsync
	# Preserves deterministic metadata
	#
	# Flow:
	# 1. Process incoming packages
	# 2. Rebuild repository metadata (per affected repo)
	# ==========================================================

	get_pwd_dir
	check_if_root_uid

	[ -z "$CASEPACKAGES" ] && {
		echog " * Must specify .nho packages."
		exit 1
	}

	[ -z "$REPO_ROOT" ] && {
		echog " * Must specify --repo-dir."
		exit 1
	}

	[ ! -d "$REPO_ROOT" ] && {
		echog " * Repository root does not exist."
		exit 1
	}

	cleanup_tmp_dir
	make_tmp_dir

	# ----------------------------------------------------------
	# 1. Process incoming packages
	# ----------------------------------------------------------
	for pkgpath in $CASEPACKAGES; do
		case "$pkgpath" in
			--*) continue ;;
		esac

		[ ! -f "$pkgpath" ] && {
			echog " * Package not found: $pkgpath"
			continue
		}

		echogn " :: Adding package:"
		echo " $(basename "$pkgpath")"

		# Extract nhoid safely
		tar xfO "$pkgpath" nhoid > "$NHOPKG_TMPDIR/nhoid" 2>/dev/null || {
			echog " * Invalid package."
			continue
		}

		get_nhoid_data "$NHOPKG_TMPDIR/nhoid"

		repo="${pkgrepo:-extra}"
		repodir="$REPO_ROOT/$repo"

		mkdir -p "$repodir"

		# Remove older versions automatically
		for old in "$repodir"/"$pkgname"-*.nho; do
		   [ -f "$old" ] && rm -f "$old"
		done

		cp "$pkgpath" "$repodir/"

		# Prepare repo staging structure
		mkdir -p "$NHOPKG_TMPDIR/$repo/packages"
		mkdir -p "$NHOPKG_TMPDIR/$repo/files"

		meta_name="$pkgname-$pkgversion-$pkgrevision"

		cp "$NHOPKG_TMPDIR/nhoid" \
		   "$NHOPKG_TMPDIR/$repo/packages/$meta_name"

		# Extract file list silently
		tar xf "$pkgpath" -C "$NHOPKG_TMPDIR" data.tar.zst 2>/dev/null

		if [ -f "$NHOPKG_TMPDIR/data.tar.zst" ]; then
			zstd -dc "$NHOPKG_TMPDIR/data.tar.zst" 2>/dev/null | \
			tar -tf - 2>/dev/null > \
			"$NHOPKG_TMPDIR/$repo/files/$meta_name"

			rm -f "$NHOPKG_TMPDIR/data.tar.zst"
		fi
	done

	# ----------------------------------------------------------
	# 2. Rebuild repository metadata (per affected repo)
	# ----------------------------------------------------------
	for repo in "$NHOPKG_TMPDIR"/*; do
		[ -d "$repo" ] || continue

		reponame=$(basename "$repo")
		repodir="$REPO_ROOT/$reponame"

		echogn " :: Updating repository:"
		echo " $reponame"

		mkdir -p "$repodir"

		# ---------- PACKAGES ----------
		tmpbuild="$repodir/.build.$$"
		mkdir -p "$tmpbuild"

		if [ -f "$repodir/core.packages.tar.zst" ]; then
			zstd -dc "$repodir/core.packages.tar.zst" 2>/dev/null | \
			tar xf - -C "$tmpbuild" 2>/dev/null
		fi

		for newmeta in "$repo/packages/"*; do
			[ -f "$newmeta" ] || continue

			get_basic_data "$newmeta"
			full="$pkgname-$pkgversion-$pkgrevision"

			rm -f "$tmpbuild/$pkgname"-*
			rm -f "$tmpbuild/$pkgname"

			cp "$newmeta" "$tmpbuild/$full"

			ln -sf "$full" "$tmpbuild/$pkgname-$pkgversion"
			ln -sf "$full" "$tmpbuild/$pkgname"
		done

		tar cf "$repodir/.packages.$$" -C "$tmpbuild" . 2>/dev/null
		zstd -q -f "$repodir/.packages.$$"
		mv -f "$repodir/.packages.$$.zst" \
			  "$repodir/core.packages.tar.zst"

		rm -rf "$tmpbuild" "$repodir/.packages.$$"

		# ---------- FILES ----------
		tmpfiles="$repodir/.files.$$"
		mkdir -p "$tmpfiles"

		if [ -f "$repodir/core.files.tar.zst" ]; then
			zstd -dc "$repodir/core.files.tar.zst" 2>/dev/null | \
			tar xf - -C "$tmpfiles" 2>/dev/null
		fi

		for newfile in "$repo/files/"*; do
			[ -f "$newfile" ] || continue
			name=$(basename "$newfile")
			pkgbase=$(echo "$name" | sed 's/-[^-]*-[^-]*$//')

			rm -f "$tmpfiles/$pkgbase"-*
			cp "$newfile" "$tmpfiles/"
		done

		tar cf "$repodir/.filesbuild.$$" -C "$tmpfiles" . 2>/dev/null
		zstd -q -f "$repodir/.filesbuild.$$"
		mv -f "$repodir/.filesbuild.$$.zst" \
			  "$repodir/core.files.tar.zst"

		rm -rf "$tmpfiles" "$repodir/.filesbuild.$$"

		# ---------- content.db ----------
		(
			cd "$repodir"
			for f in *.nho; do
				[ -f "$f" ] || continue
				size=$(stat -c %s "$f" 2>/dev/null)
				echo "$size $f"
			done > content.db
			zstd --rm -q -f content.db
		)

		date -u +%s > "$repodir/lastsync"

		echog " - Repository $reponame updated."
	done

	cleanup_tmp_dir
	echog " - Incremental repository update completed."
	exit 0
	;;
	upgrade)
# ********************************************************************
# Upgrade: update all installed packages
# Flow:
# 1. Basic checks and repo update
# 2. Get installed packages
# 3. Detect available upgrades
# 4. Ask user
# 5. Resolve deps (READ-ONLY) + prepare download list
# 6. Download EVERYTHING (deps + upgrades)
# 7. Install dependencies first
# 8. Install upgraded packages
# 9. Finalize
# ********************************************************************
    ## 1. Basic checks and repo update
    get_pwd_dir
    check_if_root_uid

    echog " - Updating repository databases..."
    update_repositories
    check_if_ok " * Failed to update the repositories."

    ## 2. Get installed packages
    get_list_installed_packages
    if [[ ${#installedpackages[@]} -eq 0 ]]; then
        echog " * No packages are installed."
        exit 0
    fi

    ## 3. Detect available upgrades
    declare -a packages_to_update
    declare -a current_versions
    declare -a new_versions

    echog " - Checking for available updates..."
    for installed_pkg in "${installedpackages[@]}"; do
        [[ -h "${NHOPKG_LOCALSTATEDIR}/packages/${installed_pkg}" ]] && continue
        [[ ! -f "${NHOPKG_LOCALSTATEDIR}/packages/${installed_pkg}" ]] && continue

        get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${installed_pkg}"
        current_pkgname="${pkgname}"
        current_full_version="${pkgversion}-${pkgrevision}"

        package_exists_in_repos "${current_pkgname}" || continue
        get_latest_version_in_repos "${current_pkgname}" || continue

        new_full_version="${pkgversion}-${pkgrevision}"

        if version_compare "${new_full_version}" ">" "${current_full_version}"; then
            packages_to_update+=("${current_pkgname}")
            current_versions+=("${current_full_version}")
            new_versions+=("${new_full_version}")
        fi
    done

    ## 4. Ask user
    if [[ ${#packages_to_update[@]} -eq 0 ]]; then
        echog " - No updates are available."
        exit 0
    fi

    echog " - Updates are available:"
    for i in "${!packages_to_update[@]}"; do
        echo "   ${packages_to_update[$i]}: ${current_versions[$i]} -> ${new_versions[$i]}"
    done

    nhopkg_ask_follow
    check_if_ok " * Packages will not be updated."

    ## 5. Resolve deps (READ-ONLY) + prepare download list
    declare -a UPGRADE_NHOS
    unset RCASEPACKAGES ORCASEPACKAGES

    for pkg_name in "${packages_to_update[@]}"; do
        CASEPACKAGE="${pkg_name}"
        getpackage || exit 1

        # Pre-check conflicts using repo metadata
        check_package_conflicts "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${pkgname}-${pkgversion}-${pkgrevision}"

        # Load nhoid from repo package (only for deps resolution)
        check_post_dependencies "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
    done

    ## 6. Download EVERYTHING (deps + upgrades)
    echog " - Downloading upgrade packages..."
    for pkg_name in "${packages_to_update[@]}"; do
        CASEPACKAGE="${pkg_name}"
        getpackage || exit 1
        downloadpackage
        UPGRADE_NHOS+=("${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho")
    done

    ## 7. Install dependencies first
    installdownloadedeps

    ## 8. Install upgraded packages
    for nho in "${UPGRADE_NHOS[@]}"; do
        cleanup_tmp_dir
        make_tmp_dir

        tar xfC "${NHOPKG_LOCALSTATEDIR}/cache/${nho}" "${NHOPKG_TMPDIR}" || exit 1
        get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"

        check_package_sha256sum
        check_package_arch
        verify_package_signature

        # Save NEW version data
        NEW_PKGNAME="$pkgname"
        NEW_PKGVERSION="$pkgversion"
        NEW_PKGREVISION="$pkgrevision"

        # Remove OLD version
        if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}" ]]; then
            get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}"
            echog " --- Removing ${pkgname}-${pkgversion}-${pkgrevision}"
            remove_package
            remove_package_config_files
        fi

        # Restore NEW metadata (IMPORTANT)
        pkgname="$NEW_PKGNAME"
        pkgversion="$NEW_PKGVERSION"
        pkgrevision="$NEW_PKGREVISION"

        # Install
        bin_install
        bin_install_setting_up
        bin_install_create_config_files

        cleanup_tmp_dir
    done

    ## 9. Finalize
    shooter_updates
    update_local_db
    echog " - System updated successfully!"
    exit 0
    ;;
    install-group)
# ********************************************************************
# Section: Install group (from repos)
# Uses file-based package list
# Flow:
# 0. Basic checks and validate groups (from parser global)
# 1. Create temp package list file
# 2. Collect packages from groups
# 3. Normalize list (deduplicate + sanitize)
# 4. Show plan
# 5. Resolve dependencies (READ-ONLY)
# 6. Download packages
# 7. Download & install dependencies
# 8. Install group packages
# 9. Finalize
# ********************************************************************
    # 0. Basic checks and validate groups (from parser global)
    get_pwd_dir
    check_if_root_uid
    
    [ -z "$CASEPACKAGES" ] && {
        echog " * Missing group name(s) for --install-group" >&2
        exit 1
    }

    # 1. Create temp package list file
    PKG_LIST_FILE="$(mktemp /tmp/nhopkg-install-group-XXXXXX.list)" || exit 1
    trap 'rm -f "$PKG_LIST_FILE"' EXIT

    # 2. Collect packages from groups
    for GROUP in $CASEPACKAGES; do
        case "$GROUP" in
            --*|-*)
                echog " * Invalid group name: $GROUP" >&2
                exit 1
                ;;
        esac

        get_packages_by_group "$GROUP" >> "$PKG_LIST_FILE"
    done

    # 3. Normalize list (deduplicate + sanitize)
    sed -i '/^$/d; /^-/d' "$PKG_LIST_FILE"
    sort -u "$PKG_LIST_FILE" -o "$PKG_LIST_FILE"

    [ ! -s "$PKG_LIST_FILE" ] && {
        echog " * No packages to install." >&2
        exit 1
    }

    # 4. Show plan
    echog " - Packages to be installed:"
    sed 's/^/   /' "$PKG_LIST_FILE"

    nhopkg_ask_follow
    check_if_ok " * Packages will not be installed."

    # 5. Resolve dependencies (READ-ONLY)
    unset RCASEPACKAGES ORCASEPACKAGES

    while IFS= read -r pkg; do
        CASEPACKAGE="$pkg"
        getpackage || exit 1

        check_package_conflicts \
            "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${pkgname}-${pkgversion}-${pkgrevision}"

        [ "$NHOPKG_CHECKDEPS" = "yes" ] && \
            check_post_dependencies \
            "${NHOPKG_LOCALSTATEDIR}/repo/${pkgrepo}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
    done < "$PKG_LIST_FILE"

    # 6. Download packages
    echog " - Downloading packages..."

    while IFS= read -r pkg; do
        CASEPACKAGE="$pkg"
        getpackage || exit 1
        downloadpackage
    done < "$PKG_LIST_FILE"

    # 7. Download & install dependencies
    if [ "$NHOPKG_CHECKDEPS" = "yes" ]; then
        installdownloadedeps
    fi

    # 8. Install group packages
    while IFS= read -r pkg; do
        CASEPACKAGE="$pkg"
        getpackage || exit 1

        cleanup_tmp_dir
        make_tmp_dir

        tar xfC \
            "${NHOPKG_LOCALSTATEDIR}/cache/${pkgname}-${pkgversion}-${pkgrevision}.${pkgos}-${pkgarch}.nho" \
            "${NHOPKG_TMPDIR}" 2>/dev/null
        check_if_ok " * Unable to uncompress package."

        if [ -f "${NHOPKG_TMPDIR}/nhoid" ]; then
            get_nhoid_data "${NHOPKG_TMPDIR}/nhoid"
        else
            echog " * The selected package is not valid." >&2
            cleanup_tmp_dir
            exit 1
        fi

        check_package_sha256sum
        check_package_arch
        verify_package_signature

        [ -n "$REPLACES_PACKAGE" ] && remove_replaced_package "$REPLACES_PACKAGE"

        bin_install
        bin_install_setting_up
        bin_install_create_config_files

        cleanup_tmp_dir
    done < "$PKG_LIST_FILE"

    # 9. Finalize
    shooter_updates
    update_local_db
    echog " - Group installation finished successfully!"
    exit 0
    ;;
	clean)
# ********************************************************************
#
# Section: Clean Cache
# 1. Basic configurations.
# 2. Clean up cache data.
# 3. Clean up build directory.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if nhopkg is running as root.
		check_if_root_uid
		echog " - Cleaning up cache data."
		## 2. Clean up cache data.
		rm -Rf "${NHOPKG_LOCALSTATEDIR}/cache/"*
		check_if_ok " * Unable to clean up cache."
		if [[ "${NHOPKG_RECURSIVE}" = "yes" ]]; then
			echog " - Cleaning up build directory."
			## 3. Clean up build directory.
			rm -Rf "${NHOPKG_BUILDIR}/"*
			check_if_ok " * Unable to clean up build directory."
		fi
		## 4. Clean up and exit.
		exit 0
	;;
	search)
# ********************************************************************
#
# Section: Search
# 1. Basic configurations.
# 2. Search for packages.
# 3. Shows packages.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			## 2. Search for packages.
			echogn " :: Searching for:"
			echo " ${CASEPACKAGE}"
			declare -a RESULTS
			RESULTS=($(find "${NHOPKG_LOCALSTATEDIR}/repo/packages/" -iname "*${CASEPACKAGE}*" -type f))
			if [[ "${#RESULTS[@]}" != "0" ]]; then
				echogn " - Results found:"
				echo " ${#RESULTS[@]}"
			else
				echog " * No results found." >&2
				exit 1
			fi
			## 3. Shows packages.
			for result in ${RESULTS[*]};
			do
				get_basic_data "${result}"
				echo
				echogn "Package:"
				echo " ${pkgname}"
				echogn "Description:"
				echo " ${pkgdescription}"
				echogn "Lasted version avaliable:"
				echo " ${pkgversion}-${pkgrevision}"
				if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
					get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
					echogn "Lasted version installed:"
					echo " ${pkgversion}-${pkgrevision}"
				else
					echog "Lasted version installed: Not installed."
				fi
			done
		done
		## 4. Clean up and exit.
		exit 0
	;;
	list-repo)
# ********************************************************************
#
# Section: List Repo
# 1. Basic configurations.
# 2. Get packages on repository.
# 3. Shows packages.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		echogn " :: Listing packages on repository:"
		echo " ${NHOPKG_REPO}"
		## 2. Get packages on repository.
		if [[ ! $(ls "${NHOPKG_LOCALSTATEDIR}/repo/packages/") ]]; then
			echog " * No results found" >&2
			exit 1
		fi
		for packagerepo in $(ls "${NHOPKG_LOCALSTATEDIR}/repo/packages/");
		do
			if [[ ! -h "${NHOPKG_LOCALSTATEDIR}/repo/packages/${packagerepo}" ]]; then
				## 3. Shows packages.
				get_basic_data "${NHOPKG_LOCALSTATEDIR}/repo/packages/${packagerepo}"
				echo
				echogn "Package:"
				echo " ${pkgname}"
				echogn "Description:"
				echo " ${pkgdescription}"
				echogn "Lasted version avaliable:"
				echo " ${pkgversion}-${pkgrevision}"
				if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
					get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${pkgname}-${pkgversion}-${pkgrevision}"
					echogn "Lasted version installed:"
					echo " ${pkgversion}-${pkgrevision}"
				else
					echog "Lasted version installed: Not installed."
				fi
			fi
		done
		## 4. Clean up and exit.
		exit 0
	;;
	list)
# ********************************************************************
#
# Section: List
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Shows installed packages.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		echog " :: Listing installed packages."
		LOG_FILE="${OUTPUT_COMMAND}/installed-packages-$(date).log"
		## 2. Get packages on repository.
		if [[ ! $(ls "${NHOPKG_LOCALSTATEDIR}/packages/") ]]; then
			echog " * No results found" >&2
			exit 1
		fi
		for installedpackage in $(ls "${NHOPKG_LOCALSTATEDIR}/packages/");
		do
			if [[ ! -h "${NHOPKG_LOCALSTATEDIR}/packages/${installedpackage}" ]]; then
				get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${installedpackage}"
				if [[ "${USE_OUTPUT_COMMAND}" = "yes" ]]; then
					echo >> "${LOG_FILE}"
					echogn "Package:" >> "${LOG_FILE}"
					echo " ${pkgname}" >> "${LOG_FILE}"
					echogn "Description:" >> "${LOG_FILE}"
					echo " ${pkgdescription}" >> "${LOG_FILE}"
					if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
						get_basic_data "${NHOPKG_LOCALSTATEDIR}/repo/packages/${pkgname}-${pkgversion}-${pkgrevision}"
						echogn "Lasted version avaliable:" >> "${LOG_FILE}"
						echo " ${pkgversion}-${pkgrevision}" >> "${LOG_FILE}"
					else
						echog "Lasted version avaliable: Not avaliable." >> "${LOG_FILE}"
					fi
				else
					## 3. Shows packages.
					echo
					echogn "Package:"
					echo " ${pkgname}"
					echogn "Description:"
					echo " ${pkgdescription}"
					if [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/packages/${pkgname}-${pkgversion}-${pkgrevision}" ]]; then
						get_basic_data "${NHOPKG_LOCALSTATEDIR}/repo/packages/${pkgname}-${pkgversion}-${pkgrevision}"
						echogn "Lasted version avaliable:"
						echo " ${pkgversion}-${pkgrevision}"
					else
						echog "Lasted version avaliable: Not avaliable."
					fi
				fi
			
			fi
		done
		## 4. Clean up and exit.
		if [[ "${USE_OUTPUT_COMMAND}" = "yes" ]]; then
			if [[ -f "${LOG_FILE}" ]]; then
				echogn " --- You can see the log on"
				echo " ${LOG_FILE}"
			else
				echog " *** Unable to write log file. Have you write permissions?" >&2
				exit 1
			fi
		fi
		exit 0
	;;
	info)
# ********************************************************************
#
# Section: Info
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Shows package info and files.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if have selected any package.
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			## 3. Shows package info and files.
			if [[ "${USE_OUTPUT_COMMAND}" = "yes" ]]; then
				LOG_FILE="${OUTPUT_COMMAND}/${CASEPACKAGE}-$(date).log"
				get_package_info "${CASEPACKAGE}" >> "${LOG_FILE}"
				check_if_ok " * Unable to get info of selected package, seems that doesn't exist."
				if [[ -f "${LOG_FILE}" ]]; then
					echogn " --- You can see the log on"
					echo " ${LOG_FILE}"
				else
					echog " *** Unable to write log file. Have you write permissions?" >&2
					exit 1
				fi
			
			else
				echogn " :: Package info for:"
				echo " ${CASEPACKAGE}"
				get_package_info "${CASEPACKAGE}"
				check_if_ok " * Unable to get info of selected package, seems that doesn't exist."
			fi
		done
		## 4. Clean up and exit.
		exit 0
	;;
	show)
# ********************************************************************
#
# Section: Show
# 1. Basic configurations.
# 2. Checking packages and prepare it.
# 3. Shows package files.
# 4. Clean up and exit.
#
# ********************************************************************
		## 1. Basic configurations.
		# Sets PWD directory.
		get_pwd_dir
		# Checks if have selected any package.
		if [[ -z "${CASEPACKAGES}" ]]; then
			echog " * Must select package." >&2
			exit 1
		fi
		## 2. Checking packages and prepare it.
		for CASEPACKAGE in ${CASEPACKAGES};
		do
			## 3. Shows package files.
			if [[ -f "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}" ]]; then
				get_basic_data "${NHOPKG_LOCALSTATEDIR}/packages/${CASEPACKAGE}"
				if [[ ! $(zstdcat "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst" 2> /dev/null) ]]; then
					echog " * Muah Muah Muah!! Seems that maintainer of this package don't know how to create a good package or had a problem during installation." >&2
					exit 1
				fi
				if [[ "${USE_OUTPUT_COMMAND}" = "yes" ]]; then
					LOG_FILE="${OUTPUT_COMMAND}/${CASEPACKAGE}-$(date).log"
					zstdcat "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst" >> "${LOG_FILE}"
					if [[ -f "${LOG_FILE}" ]]; then
						echogn " --- You can see the log on"
						echo " ${LOG_FILE}"
					else
						echog " *** Unable to write log file. Have you write permissions?" >&2
						exit 1
					fi
				else
					zstdcat "${NHOPKG_LOCALSTATEDIR}/files/${pkgname}-${pkgversion}-${pkgrevision}.zst"
				fi
			elif [[ -f "${NHOPKG_LOCALSTATEDIR}/repo/packages/${CASEPACKAGE}" ]]; then
				get_basic_data "${NHOPKG_LOCALSTATEDIR}/repo/packages/${CASEPACKAGE}"
				if [[ ! $(zstdcat "${NHOPKG_LOCALSTATEDIR}/repo/files/${pkgname}-${pkgversion}-${pkgrevision}.zst" 2> /dev/null) ]]; then
					echog " * Muah Muah Muah!! Seems that maintainer of this package don't know how to create a good package or had a problem during installation." >&2
					exit 1
				fi
				if [[ "${USE_OUTPUT_COMMAND}" = "yes" ]]; then
					LOG_FILE="${OUTPUT_COMMAND}/${CASEPACKAGE}-$(date).log"
					zstdcat "${NHOPKG_LOCALSTATEDIR}/repo/files/${pkgname}-${pkgversion}-${pkgrevision}.zst" >> "${LOG_FILE}"
					if [[ -f "${LOG_FILE}" ]]; then
						echogn " --- You can see the log on"
						echo " ${LOG_FILE}"
					else
						echog " *** Unable to write log file. Have you write permissions?" >&2
						exit 1
					fi
				else
					zstdcat "${NHOPKG_LOCALSTATEDIR}/repo/files/${pkgname}-${pkgversion}-${pkgrevision}.zst"
				fi
			# For local .nho packages.
			elif [[ -f "${CASEPACKAGE}" ]] && [[ $(basename "${CASEPACKAGE}" .nho) != "${CASEPACKAGE}" ]]; then
				if [[ "${USE_OUTPUT_COMMAND}" = "yes" ]]; then
					LOG_FILE="${OUTPUT_COMMAND}/${CASEPACKAGE}-$(date).log"
					zstdcat "${CASEPACKAGE}" | tar --extract --to-stdout | zstd -d -q -c 2> /dev/null >> "${LOG_FILE}"
					if [[ -f "${LOG_FILE}" ]]; then
						echogn " --- You can see the log on"
						echo " ${LOG_FILE}"
					else
						echog " *** Unable to write log file. Have you write permissions?" >&2
						exit 1
					fi
				else
					zstdcat "${CASEPACKAGE}" | tar --extract --to-stdout | zstd -d -q -c 2> /dev/null | tar --list

				fi
			else
				echog " * The selected package is not installed by Nhopkg." >&2
				# Clean up and exits.
				exit 1
			fi
		done
		## 4. Clean up and exit.
		exit 0
	;;
	update-shooters)
		check_if_root_uid
		shooter_updates
		exit 0
	;;
	update-db)
		check_if_root_uid
		update_local_db
		exit 0
	;;
	license)
		nhopkg_license
		exit 0
	;;
	license-all)
		cat "${NHOPKG_DATADIR}/COPYING"
		exit 0
	;;
	version)
		nhopkg_version
		exit 0
	;;
	help)
		# Shows help pages.
		nhopkg_help
		exit 0
	;;
	*)
		# Shows help pages.
		echog " * You need to give some command." >&2
		nhopkg_help
		exit 1
	;;
esac
